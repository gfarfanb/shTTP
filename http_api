#! /usr/bin/env bash
#  Simple HTTP API development environment.
#  -author Giovanni Farf√°n B.
set -euo pipefail
IFS=$'\n\t'

#  Help content.
_shttp_help_content=(
    ""
    " Simple HTTP API development environment by command line."
    ""
    " Usage: ./<file>[.sh] <command> [<manage-options>] [<request-options>]"
    ""
    "                                [--help] [<add-on-options>]"
    ""
    " Manage options:"
    "   --list:                           Display the <command> list (all functions defined into main script)"
    "   --envs:                           Display all environments based on configuration files"
    "   --copy <env-from> <env-to>:       Copy the environment configuration and credentials files. Must exist the 'from'"
    "                                       configuration files. If already exist the 'to' files those will be replaced."
    "                                       If is required to copy from 'default' environment, the first parameters must"
    "                                       contain 'default'"
    "   --del <env>:                      Remove the selected environment: configuration and credentials files. If is"
    "                                       required to remove 'default' environment, the parameter must contain 'default'"
    "   --get <key-name>:                 Display the value for key from 'ws/config[.<env>].json'"
    "   --add <key-name> <value> <sec>:   Add new key-value to 'ws/config[.<env>].json'"
    "                                       <sec>:"
    "                                         -h: hidden mode, in 'ws/.vlt'"
    "                                         -s: public mode, in 'ws/config[.<env>].json'"
    "   --remove <key-name>:              Remove the key-value from 'ws/config[.<env>].json'"
    "   --keys:                           Display all keys from 'ws/config[.<env>].json' file"
    "   --part <part> <value> <sec>:      Add new credential part to 'ws/credentials[.<env>].json' and 'ws/.vlt'"
    "                                       <part>:"
    "                                         -u: username alias"
    "                                         -p: password alias"
    "                                         -k: key alias"
    "                                         -s: secret alias"
    "                                         -t: token alias"
    "                                         -i: pin alias"
    "                                       <sec>:"
    "                                         -h: hidden mode, in 'ws/.vlt'"
    "                                         -s: public mode, in 'ws/credentials[.<env>].json'"
    "   --creds:                          Display all credentials ids from 'ws/credentials[.<env>].json'"
    "   --cred-keys <credential>:         Display all keys from 'ws/credentials[.<env>].json' file for a specific credential"
    "   --curl <body-opt>                 Display the related cURL command for the input <command>"
    "                                       <body-opt>:"
    "                                         -f: show the body as filename only"
    "                                         -c: show the body as content"
    "   --clean:                          Clean up all output files 'output/*'"
    ""
    " Request options:"
    "   --env <env>:                      Set the environment for script by changing configuration and credentials files:"
    "                                       'ws/config[.<env>].json' and 'ws/credentials[.<env>].json'"
    "   --cred <credential>:              Set the credential for script by updating '_shttp_auth_credential"
    "   --set <key-name> <value>:         Set a temporal key-value config. This won't saved to 'ws/config[.<env>].json'"
    "   --local <port>:                   Set variables to local execution:"
    "                                       _shttp_protocol: http"
    "                                       _shttp_domain: localhost:<port> (default 8080)"
    "   --port <port>:                    Set value to port variable"
    "   --auth-basic <credential>:        Set 'BASIC' mode to '_shttp_auth_mode' and assign the credential"
    "   --auth-header <credential>:       Set 'HEADER' mode to '_shttp_auth_mode' and assign the credential"
    "   --auth-qtoken <credential>:       Set 'QTOKEN' mode to '_shttp_auth_mode' and assign the credential"
    "   --auth-qkeysec <credential>:      Set 'QKEYSEC' mode to '_shttp_auth_mode' and assign the credential"
    "   --auth-skip <credential>:         Set 'SKIP' mode to '_shttp_auth_mode' and assign the credential"
    "   --times <value>:                  Set the number of executions required for the request into '_shttp_request_times'"
    "   --open:                           Set '_shttp_editor_command' with value defined on 'editorCommand'"
    "                                       from 'ws/config[.<env>].json'. This causes to execute '_shttp_editor_command'"
    " Manual options:"
    "   --help:                           Display this help message"
    ""
    " Environment variables:"
    "   SAVED_LOGS:                       'true' for saved logs on '/tmp/_shttp_basename.yyyy-mm-dd.log'"
    "                                       otherwise logs only will print by 'echo' function"
    " Add-on options: "
)

#  Script filename.
readonly _shttp_basename=$( basename "$0" )


# ---------- Logging functions

SAVED_LOGS=${SAVED_LOGS:-"false"}
if [ "$SAVED_LOGS" == "true" ]; then

#  Log filename.
readonly _shttp_log_file="/tmp/shTTP_${_shttp_basename%.*}.$( date '+%Y-%m-%d' ).log"

#  Log a message with the INFO level.
#  No test required.
#
#  -param $* Log message
#  shellcheck disable=SC2086
info() { echo "$( date '+%Y-%m-%d %T.%N' ) INFO      $*" | tee -a "$_shttp_log_file" >&2 ; }

#  Log a message with the WARNING level.
#  No test required.
#
#  -param $* Log message
#  shellcheck disable=SC2086
warn() { echo "$( date '+%Y-%m-%d %T.%N' ) WARNING   $*" | tee -a "$_shttp_log_file" >&2 ; }

#  Log a message with the ERROR level.
#  No test required.
#
#  -param $* Log message
#  shellcheck disable=SC2086
error() { echo "$( date '+%Y-%m-%d %T.%N' ) ERROR     $*" | tee -a "$_shttp_log_file" >&2 ; }

#  Log a message with the FATAL level, 
#+ exit execution with 1.
#  No test required.
#
#  -param $* Log message
#  shellcheck disable=SC2086
fatal() { echo "$( date '+%Y-%m-%d %T.%N' ) FATAL     $*" | tee -a "$_shttp_log_file" >&2 ; exit 1 ; }

else

info() { echo "$( date '+%Y-%m-%d %T.%N' ) INFO      $*" ; }
warn() { echo "$( date '+%Y-%m-%d %T.%N' ) WARNING   $*" ; }
error() { echo "$( date '+%Y-%m-%d %T.%N' ) ERROR     $*" ; }
fatal() { echo "$( date '+%Y-%m-%d %T.%N' ) FATAL     $*" ; exit 1 ; }

fi


# ---------- Initialization

# 'cURL' is required
readonly _curl_version=$( curl --version )
if [ -z "$_curl_version" ]; then
    fatal "'curl' is not installed yet"
fi

#  'jq' (command-line JSON processor)
#+ is required
#+ https://github.com/stedolan/jq
readonly _jq_version=$( jq --version )
if [ -z "$_jq_version" ]; then
    warn "'jq' is not installed yet, JSON processing will not work"
fi

#  Output directory for trace and
#+ results files
if ! [ -d output ]; then
    mkdir output || fatal "Imposible to create 'output' directory"
fi

#  Output directory for execution
#+ history.
if ! [ -d hist ]; then
    mkdir hist || fatal "Imposible to create 'hist' directory"
fi

#  Workspace directory for data
#+ execution
if ! [ -d ws ]; then
    mkdir ws || fatal "Imposible to create 'ws' directory"
fi

#  Default configuration JSON file
if ! [ -f "ws/config.json" ]; then
    echo '{
        "protocol": null,
        "domain": null,
        "port": null,
        "basePath": null,
        "endpoint": null,
        "method": null,
        "headers": [],
        "body": [],
        "form": [],
        "queryParams": [],
        "curlOpts": [],
        "authMode": null,
        "authCredential": null,
        "editorCommand": null
}' > "ws/config.json"
fi

#  Default credentials JSON file
if ! [ -f "ws/credentials.json" ]; then
    echo '[{
        "id": "basic",
        "username": "Mandatory. Evaluated it during request.",
        "password": "Optional. Evaluated it during request."
    }, {
        "id": "header",
        "token": "Mandatory. Evaluated it during request.",
        "type": "[Basic | token | Bearer]"
    }, {
        "id": "qtoken",
        "token": "Mandatory. Evaluated it during request.",
        "tokenParam": "Optional. Default: access_token."
    }, {
        "id": "qkeysecret",
        "key": "Mandatory. Evaluated it during request.",
        "secret": "Mandatory. Evaluated it during request.",
        "keyParam": "Optional. Default: key.",
        "secretParam": "Optional. Default: secret."
    }]' > "ws/credentials.json"
fi

#  Override JSON file
if [ -f "ws/.override.json.tmp" ]; then
    rm -f "ws/.override.json.tmp"
fi
echo '{ }' > "ws/.override.json.tmp"


# ---------- Util functions

#  Reverse the string input.
#
#  -param $1 String input
#  -return Reversed string
str_rev() {
    local _input=${1:-}
    local _rev=""
    for (( _input_idx=${#_input}-1; _input_idx>=0; _input_idx-- )); do
        _rev="$_rev${_input:$_input_idx:1}"
    done
    echo "$_rev"
}

#  Generates a random string
#+ value with specified length.
#
#  -param $1 Required string
#+           length
#  -return Random string
str_rnd() {
    local _length=${1:-10}
    local _val=""
    _val=$( < /dev/urandom tr -dc 'a-zA-Z0-9' \
        | fold -w "$_length" \
        | head -n 1 )
    echo "$_val"
}

#  Join the elements of the
#+ array in a single string.
#
#  -param $1 Delimiter
#  -param $* Elements
#  -return Single string
arr_join() {
    local IFS="$1"
    shift
    echo "$*"
}

#  Get a random value from
#+ an array.
#
#  -param $* Elements
#  -return Random value
arr_rnd() {
    local _arr=( $@ )
    local _length=${#_arr[@]}
    echo "${_arr[$((0 + RANDOM % _length))]}"
}


# ---------- Public functions

#  Request flow step. Simulate
#+ and external request call:
#+ input parameters processing,
#+ and request execution.
#  In a flow execution contex
#+ the '--times' option
#+ does not work for steps
#+ because it is used for repeat
#+ flow execution.
#  It is recommended to use
#+ inside a flow function.
#  This is the step process:
#    1. Execute option functions
#+      based on input parameters
#    2. Log executed step
#    3. Execute request command
#    4. Reset request variables
#
#  -param $1 Request command
#  -param $@ Request options
step() {
    local _command=${1:-}
    local _last_params="$_shttp_input_params"
    shift
    mainOpts "$@"
    local _params=( $( echo "$_shttp_input_params" | tr " " "\n" ) )
    local _length=${#_params[@]}
    if (( _length > 0 )); then
        for _opt in "${_shttp_request_opts[@]}"; do
            _look_for_params "$_opt" "${_params[@]}" || continue
        done
    fi
    echo "$_command" | tee -a "$_shttp_output_flow.steps" > /dev/null
    _execute "$_command"
    _shttp_input_params="$_last_params"
}

#  Update a JSON file using 'jq'.
#
#  -param $1 JSON file
#  -param $2 Change by 'jq'
update() {
    local _json=${1:-}
    local _jq=${2:-}
    local _temp=""
    _temp="ws/.pivot.$( date '+%s.%N' ).json.tmp"
    < "$_json" jq "$_jq" > "$_temp"
    mv "$_temp" "$_json"
    info "Updated [$_json] file"
}

#  Save key-value config to 'ws/config[.<env>].json'.
#  This function has three different forms:
#    1. Only 'jq' query: put '.jq'
#    2. Name and 'jq' query: put 'name' '.jq'
#    3. Name and value: put 'name' 'value'
#  If 'jq' query is found, the function will
#+ use JSON result to take the value.
#
#  -param $1 Name of the entry or 'jq' for value
#  -param $2 Value of the entry or 'jq' for value
#  -param $3 Secure type: [PRIVATE | PUBLIC]
put() {
    local _name=${1:-}
    local _val=${2:-}
    local _sec=${3:-"PUBLIC"}
    local _jq=""
    if [ -z "$_val" ]; then
        _jq="$_name"
        _name=${_name//[0-9^\[\]]/}
        _name=$( str_rev "$_name" )
        _name=$( echo "$_name" | cut -d '.' -f 1 )
        _name=$( str_rev "$_name" )
    elif [[ "$_val" = \.* ]]; then
        _jq="$_val"
    fi
    if [ -n "$_jq" ]; then
        _val=$( < "$_shttp_output.output" jq "try $_jq catch null" )
    fi
    if [ "$_sec" = "PRIVATE" ]; then
        local _entry="$_shttp_suffix->$_name:="
        local _desc=""
        _desc=$( < "$_shttp_env" jq ".$_name")
        _entry=$( echo "$_entry" | base64 )
        _val=$( echo "$_val" | sed -e 's/^"//' -e 's/"$//' )
        _val=$( echo "$_val" | base64 )
        if [ -a "ws/.vlt" ]; then
            sed -i "/^$_entry/d" "ws/.vlt"
        fi
        echo "$_entry!$_val" | tee -a "ws/.vlt" > /dev/null
        _val="$_desc"
    fi
    update "$_shttp_env" ". + { \"$_name\": $_val }"
    info "Saved [$_name] with value [$_val] to workspace config"
}

#  Get key-value config in the following
#+ order: script variables and then from
#+ 'ws/config[.<env>].json'.
#
#  -param $1 Name of the entry or 'jq'
#+           query (without '.' at the
#+           beginning of the query)
#  -param $2 Default value if required
#+           is not found. If it is not
#+           specified 'null' will be
#+           default value.
#  -return Config value
get() {
    local _name=${1:-}
    local _default=${2:-'null'}
    local _entry=""
    local _val=""
    if [ -a "ws/.vlt" ]; then
        _entry="$_shttp_suffix->$_name:="
        _entry=$( echo "$_entry" | base64 )
        _val=$( grep -e "^$_entry" "ws/.vlt" )
    fi
    if [ -n "$_val" ]; then
        _val="${_val/"$_entry!"/}"
        _val=$( echo "$_val" | base64 --decode )
    else
        _val=$( < "ws/.override.json.tmp" jq ".$_name | tostring" )
        _val=$( echo "$_val" | sed -e 's/^"//' -e 's/"$//' )
        if [ "$_val" = "null" ]; then
            _val=""
        fi
        if [ -z "$_val" ]; then
            _val=$( jq ".$_name | tostring" "$_shttp_env" )
            _val=$( echo "$_val" | sed -e 's/^"//' -e 's/"$//' )
            if [ "$_val" = "null" ]; then
                _val="$_default"
            fi
        fi
    fi
    echo "$_val"
}

#  Remove key-value from 'ws/config[.<env>].json'.
#  This function has two different forms:
#    1. 'jq' query: remove '.jq'
#    2. Field name: remove 'name'
#
#  -param $1 Name of the entry
remove() {
    local _name=${1:-}
    if [[ "$_name" = \.* ]]; then
        local _val=""
        _val=$( jq "try $_name catch null" "$_shttp_env" )
        if [ "$_val" != "null" ]; then
            update "$_shttp_env" "del($_name)"
            info "Removed [$_name] from workspace config"
        fi
    else
        local _found=""
        _found=$( jq "has(\"$_name\")" "$_shttp_env" )
        if [ "$_found" = "true" ]; then
            update "$_shttp_env" "del(.$_name)"
            info "Removed [$_name] from workspace config"
        fi
    fi
}

#  Save credential part for
#+ '_shttp_auth_credential'.
# 
#  -param $1 Part name
#  -param $2 Part value
#  -param $3 Secure type:
#+           [PRIVATE | PUBLIC]
#  -param $4 Credential
putPart() {
    local _part=${1:-}
    local _val=${2:-}
    local _sec=${3:-"PRIVATE"}
    local _credential=${4:-"$_shttp_auth_credential"}
    local _cred_idx=-1
    _cred_idx=$( < "$_shttp_creds" \
        jq "map(.id==\"$_credential\") | index(true)" )
    if [ "$_cred_idx" = "null" ]; then
        fatal "Credential [$_credential] not found"
    fi
    if [ "$_sec" = "PRIVATE" ]; then
        local _entry="$_shttp_suffix->$_credential->$_part:="
        local _desc=""
        _desc=$( < "$_shttp_creds" \
            jq ".[] | select(.id==\"$_credential\") | .$_part")
        _entry=$( echo "$_entry" | base64 )
        _val=$( echo "$_val" | base64 )
        if [ -a "ws/.vlt" ]; then
            sed -i "/^$_entry/d" "ws/.vlt"
        fi
        echo "$_entry!$_val" | tee -a "ws/.vlt" > /dev/null
        _val="$_desc"
    fi
    update "$_shttp_creds" ".[$_cred_idx].$_part=$_val"
    info "Saved [$_part] with value [$_val] to credential [$_credential]"
}

#  Get the credential part for
#+ '_shttp_auth_credential'.
#
#  -param $1 Part name
#  -param $2 Default value
#  -param $3 Credential
#  -return Credential part value
getPart() {
    local _part=${1:-}
    local _default=${2:-'null'}
    local _credential=${3:-"$_shttp_auth_credential"}
    local _entry=""
    local _val=""
    if [ -a "ws/.vlt" ]; then
        _entry="$_shttp_suffix->$_credential->$_part:="
        _entry=$( echo "$_entry" | base64 )
        _val=$( grep -e "^$_entry" "ws/.vlt" )
    fi
    if [ -n "$_val" ]; then
        _val="${_val/"$_entry!"/}"
        _val=$( echo "$_val" | base64 --decode )
    else
        _val=$( < "$_shttp_creds" \
            jq ".[] | select(.id==\"$_credential\") | .$_part")
        _val=$( echo "$_val" | sed -e 's/^"//' -e 's/"$//' )
        if [ "$_val" = "null" ]; then
            _val="$_default"
        fi
    fi
    echo "$_val"
}

#  Get JSON value from
#+ '$_shttp.output.output'.
#
#  -param $1 Name of the entry or 'jq'
#+           query (without '.' at the
#+           beginning of the query)
#  -param $2 Default value if required
#+           is not found. If it is not
#+           specified 'null' will be
#+           default value.
#  -return JSON value
getOutput() {
    local _name=${1:-}
    local _default=${2:-'null'}
    local _val=""
    _val=$( < "$_shttp_output.output" jq ".$_name | tostring" )
    _val=$( echo "$_val" | sed -e 's/^"//' -e 's/"$//' )
    if [ "$_val" = "null" ]; then
        _val="$_default"
    fi
    echo "$_val"
}

#  Get the Header value
#+ from response
#+ 'shttp_output.trace'.
#
#  -param $1 Response header name
#  -param $2 Default value
getHeader() {
    local _header=${1:-}
    local _default=${2:-'null'}
    local _val=""
    _header="$_header:"
    if [ -f "$_shttp_output.trace" ]; then
        _val=$( grep -e "^$_header" "$_shttp_output.trace" | tail -1 )
        if [ -n "$_val" ]; then
            _val=${_val/$_header/}
            _val=$( echo "$_val" | xargs echo -n )
        else
            _val="$_default"
        fi
    else
        _val="$_default"
    fi
    echo "$_val"
}

#  Get HTTP status code
#+ from 'shttp_output.trace'.
#
#  -param $1 Default value
#  shellcheck disable=SC2120
getStatus() {
    local _default=${1:-'null'}
    getHeader http_code "$_default"
}


# ---------- Assertion functions

#  Assert that a given 'Bash Conditional
#+ Expressions' is true.
#
#  -param $1 Fail message
#  -param $2 Condition content:
#+           '[ <$2> ]'
isTrue() {
    local _message=${1:-}
    local _condition=${2:-}
    local _ok=1
    eval "if ! [ $_condition ]; then _ok=0 ; fi"
    if [ $_ok = 0 ]; then
        _shttp_failures=$(( _shttp_failures+1 ))
        _shttp_failures_flow=$(( _shttp_failures_flow+1 ))
        _failed_log "[ $_condition ]: $_message"
    fi
    _shttp_assertions=$(( _shttp_assertions+1 ))
    _shttp_assertions_flow=$(( _shttp_assertions_flow+1 ))
}

#  Assert that a given 'Bash Conditional
#+ Expressions' is false.
#
#  -param $1 Fail message
#  -param $2 Condition content:
#+           '! [ <$2> ]'
isFalse() {
    local _message=${1:-}
    local _condition=${2:-}
    local _ok=1
    eval "if [ $_condition ]; then _ok=0 ; fi"
    if [ $_ok = 0 ]; then
        _shttp_failures=$(( _shttp_failures+1 ))
        _shttp_failures_flow=$(( _shttp_failures_flow+1 ))
        _failed_log "! [ $_condition ]: $_message"
    fi
    _shttp_assertions=$(( _shttp_assertions+1 ))
    _shttp_assertions_flow=$(( _shttp_assertions_flow+1 ))
}

#  Assert that expected and actual
#+ are equal to one another.
#
#  -param $1 Fail message
#  -param $2 Expected value
#  -param $3 Actual value
areEquals() {
    local _message=${1:-}
    local _expected=${2:-}
    local _actual=${3:-}
    if [ "$_expected" != "$_actual" ]; then
        _shttp_failures=$(( _shttp_failures+1 ))
        _shttp_failures_flow=$(( _shttp_failures_flow+1 ))
        _failed_log "[ $_expected = $_actual ]: $_message"
    fi
    _shttp_assertions=$(( _shttp_assertions+1 ))
    _shttp_assertions_flow=$(( _shttp_assertions_flow+1 ))
}

#  Assert that unexpected and actual
#+ are not equal to one another.
#
#  -param $1 Fail message
#  -param $2 Expected value
#  -param $3 Actual value
areNotEquals() {
    local _message=${1:-}
    local _expected=${2:-}
    local _actual=${3:-}
    if [ "$_expected" = "$_actual" ]; then
        _shttp_failures=$(( _shttp_failures+1 ))
        _shttp_failures_flow=$(( _shttp_failures_flow+1 ))
        _failed_log "[ $_expected != $_actual ]: $_message"
    fi
    _shttp_assertions=$(( _shttp_assertions+1 ))
    _shttp_assertions_flow=$(( _shttp_assertions_flow+1 ))
}

#  Assert that expected and actual
#+ are like to one another.
#
#  -param $1 Fail message
#  -param $2 Like regex
#  -param $3 Actual value
isLike() {
    local _message=${1:-}
    local _expected=${2:-}
    local _actual=${3:-}
    if ! [[ "$_actual" =~ $_expected ]]; then
        _shttp_failures=$(( _shttp_failures+1 ))
        _shttp_failures_flow=$(( _shttp_failures_flow+1 ))
        _failed_log "[[ $_actual =~ $_expected ]]: $_message"
    fi
    _shttp_assertions=$(( _shttp_assertions+1 ))
    _shttp_assertions_flow=$(( _shttp_assertions_flow+1 ))
}

#  Assert that unexpected and actual
#+ are not like to one another.
#
#  -param $1 Fail message
#  -param $2 Like regex
#  -param $3 Actual value
isNotLike() {
    local _message=${1:-}
    local _expected=${2:-}
    local _actual=${3:-}
    if [[ "$_actual" =~ $_expected ]]; then
        _shttp_failures=$(( _shttp_failures+1 ))
        _shttp_failures_flow=$(( _shttp_failures_flow+1 ))
        _failed_log "! [[ $_actual =~ $_expected ]]: $_message"
    fi
    _shttp_assertions=$(( _shttp_assertions+1 ))
    _shttp_assertions_flow=$(( _shttp_assertions_flow+1 ))
}

#  Assert that actual is
#+ equals to null.
#
#  -param $1 Fail message
#  -param $2 Actual value
isNull() {
    local _message=${1:-}
    local _actual=${2:-}
    if [ "$_actual" != "null" ]; then
        _shttp_failures=$(( _shttp_failures+1 ))
        _shttp_failures_flow=$(( _shttp_failures_flow+1 ))
        _failed_log "[ $_actual = null ]: $_message"
    fi
    _shttp_assertions=$(( _shttp_assertions+1 ))
    _shttp_assertions_flow=$(( _shttp_assertions_flow+1 ))
}

#  Assert that actual is
#+ not equals to null.
#
#  -param $1 Fail message
#  -param $2 Actual value
isNotNull() {
    local _message=${1:-}
    local _actual=${2:-}
    if [ "$_actual" = "null" ]; then
        _shttp_failures=$(( _shttp_failures+1 ))
        _shttp_failures_flow=$(( _shttp_failures_flow+1 ))
        _failed_log "[ $_actual != null ]: $_message"
    fi
    _shttp_assertions=$(( _shttp_assertions+1 ))
    _shttp_assertions_flow=$(( _shttp_assertions_flow+1 ))
}


# ---------- Variables initialization

#  Request URL. During request,
#+ if its value is empty, the URL
#+ will be build by:
#+ '<protocol>://<domain><base-path><endpoint>'
_shttp_url=""

#  Request protocol:
#+ '<protocol>://any.host/any/endpoint'
_shttp_protocol=""

#  Request domain:
#+ 'https://<domain>/any/endpoint'
_shttp_domain=""

#  Request port:
#+ 'https://any.domain<:port>/any/endpoint'
_shttp_port=""

#  Request base path:
#+ 'https://any.host/<base-path>/endpoint'
_shttp_base_path=""

#  Request endpoint:
#+ 'https://any.host/any/<endpoint>'
_shttp_endpoint=""

#  Request method.
#  Allowed values:
#+   [GET, POST, PUT, PATCH,
#+   DELETE, HEAD, OPTIONS]
_shttp_method=""

#  Request headers. Default values
#+ for [Content-Type, Authorization, Host]
#+ could be assigned during request
#+ execution.
_shttp_headers=()

#  Request body filename. During
#+ request execution will be
#+ appended to 'cURL'.
_shttp_body=""

#  Request key-value entries for
#+ data form. If it is specified
#+ default 'Content-Type' header
#+ will be 'multipart/form-data'
#+ otherwise will be 'application/json'.
_shttp_form=()

#  Request key-value entries for
#+ Query Parameters.
_shttp_query_params=()

#  Additional 'cURL' options.
_shttp_curl_opts=()

#  Authorization mode. Allowed values:
#+ [BASIC, HEADER, QPARAM, SKIP].
#    1. BASIC: HTTP Basic Authentication
#    2. HEADER: Header Authorization
#    3. QPARAM: Authorization via Query
#+      Parameters
#    4. SKIP: No authorization mode
_shttp_auth_mode=""

#  Authentication credential identifier.
#  The credential must be in 
#+ 'ws/credentials[.<env>].json'.
#  Regarding to '_shttp_auth_mode'
#+ credential must have the
#+ following fields:
#    1. BASIC: 'username', 'password'
#    2. HEADER: 'token', 'type'
#    3. QTOKEN: 'token', 'tokenParam'
#    3. QKEYSEC: 'key', 'secret',
#+      'keyParam', 'secretParam'
_shttp_auth_credential=""

#  Current request command.
_shttp_current_request=""

#  Current flow command.
_shttp_current_flow=""

#  Number of request executions.
_shttp_request_times=0

#  If value is defined, that command
#+ will be executed as last tasks
#+ of the request.
_shttp_editor_command=""

#  Open editor command flag.
#+ Allowed values:
#    1: true
#    0: false
_shttp_open_editor=0

#  Request execution date with
#+ the following format:
#+ yymmdd.hhmmss.000000000
_shttp_date=""

#  Request execution date with
#+ the following format:
#+ yymmdd.hhmmss.000000000
_shttp_date_flow=""

#  Response output base filename.
#  During request this filename
#+ will be used for make files:
#+ '<output>.output', '<output>.trace'
#+ and '<output>.failed'.
_shttp_output=""

#  Response output base filename
#+ for flows.
#  During request this filename
#+ will be used for make files:
#+ '<output>.trace' and 
#+ '<output>.failed'.
_shttp_output_flow=""

#  Current environment suffix.
_shttp_suffix="default"

#  Configuration environment file.
#+ If environment is assigned
#+ file will have this form:
#+ 'ws/config.<env>.json'.
_shttp_env="ws/config.json"

#  Credentials environment file.
#+ If environment is assigned
#+ file will have this form:
#+ 'ws/credentials.<env>.json'.
_shttp_creds="ws/credentials.json"

#  Script input parameters.
_shttp_input_params="${*}"

#  Execution type, allowed values:
#    1. FLOW: End-to-end process
#    2. REQUEST: Single request
_shttp_execution_type=""

#  Current number of flow.
#  This field is updated by
#+ '_execute_flow' for each
#+ iteration.
#  This value will be reset
#+ after complete all iterations.
_shttp_flow_index=0

#  Current number of execution.
#  This field is updated by
#+ '_execute' for each iteration.
#  This value will be reset
#+ after complete all iterations.
_shttp_request_index=0

#  Script execution status:
#    = 0: Success
#    > 0: Failed 
_shttp_status=0

#  Assertions count.
_shttp_assertions_flow=0

#  Failed assertions count.
_shttp_failures_flow=0

#  Assertions count.
_shttp_assertions=0

#  Failed assertions count.
_shttp_failures=0

#  List of request options.
_shttp_request_opts=()

#  List of registered options.
declare -A _shttp_registered_opts

#  Flag for enable request
#+ mock:
#    1: enabled
#    0: disabled
_shttp_mock_enabled=0

#  Mock output filename.
_shttp_mock_output=""

#  Mock trace filename.
_shttp_mock_trace=""


# ---------- Builder functions

#  Setter for '_shttp_url'.
#
#  -param $1 Request URL
url() {
    local _url=${1:-}
    _shttp_url="$_url"
    info "Set [URL] with [$_shttp_url]"
}

#  Setter for '_shttp_protocol'.
#
#  -param $1 Request Protocol
protocol() {
    local _protocol=${1:-}
    _shttp_protocol="$_protocol"
    info "Set [Protocol] with [$_shttp_protocol]"
}

#  Setter for '_shttp_domain'.
#
#  -param $1 Request domain
domain() {
    local _domain=${1:-}
    _shttp_domain="$_domain"
    info "Set [Domain] with [$_shttp_domain]"
}

#  Setter for '_shttp_port'.
#
#  -param $1 Request port
port() {
    local _port=${1:-}
    _shttp_port="$_port"
    info "Set [Port] with [$_shttp_port]"
}

#  Setter for '_shttp_base_path'.
#
#  -param $1 Request base path
basePath() {
    local _path=${1:-}
    _shttp_base_path="$_path"
    info "Set [Base-path] with [$_shttp_base_path]"
}

#  Setter for '_shttp_endpoint'.
#
#  -param $1 Request endpoint
endpoint() {
    local _endpoint=${1:-}
    _shttp_endpoint="$_endpoint"
    info "Set [Endpoint] with [$_shttp_endpoint]"
}

#  Setter for '_shttp_method'.
#
#  -param $1 Request method
method() {
    local _method=${1:-}
    case "$_method" in
        GET \
        | POST \
        | PUT \
        | PATCH \
        | DELETE \
        | HEAD \
        | OPTIONS)
            _shttp_method="$_method"
            info "Set [Method] with [$_shttp_method]"
        ;;
        *)
            fatal "Invalid [$_method] request method"
        ;;
    esac
}

#  Setter for '_shttp_headers'.
#
#  -param $@ Request headers
headers() {
    if (( $# > 0 )); then
        for _header in "$@"; do
            _shttp_headers+=( "$_header" )
            info "Set [Header] with [$_header]"
        done
    fi
}

#  Setter for '_shttp_body' file.
#
#  -param $1 Offset value
#  -param $2 Repeat option:
#+           '[0-9]+t' for times
#+           '[0-9]+s' for size
#+           in bytes
#  -param $@ Request body parts
#  -see _append_content_file
body() {
    if ! [ -f "$_shttp_body" ]; then
        _shttp_body="ws/.body.$( date '+%s.%N' ).json.tmp"
    fi
    _append_content_file "$_shttp_body" "$@"
}

#  Setter for '_shttp_body' file.
#+ A request body file is directly
#+ defined by this function.
#
#  -param $1 Body filename
bodyFile() {
    local _body_file=${1:-}
    if [ -n "$_body_file" ]; then
        _shttp_body="ws/.body.$( date '+%s.%N' ).json.tmp"
        cp "$_body_file" "$_shttp_body"
    fi
}

#  Setter for '_shttp_form'.
#
#  -param $@ Request form
form() {
    if (( $# > 0 )); then
        for _form in "$@"; do
            _shttp_form+=( "$_form" )
            info "Set [Form] with [$_form]"
        done
    fi
}

#  Setter for '_shttp_query_params'.
#
#  -param $@ Request query parameters
queryParams() {
    if (( $# > 0 )); then
        for _param in "$@"; do
            _shttp_query_params+=( "$_param" )
            info "Set [Query-Param] with [$_param]"
        done
    fi
}

#  Setter for '_shttp_curl_opts'.
#
#  -param $@ Additional cURL options
curlOpts() {
    if (( $# > 0 )); then
        for _opt in "$@"; do
            _shttp_curl_opts+=( "$_opt" )
            info "Set [cURL-opt] with [$_opt]"
        done
    fi
}

#  Setter for '_shttp_auth_mode'.
#
#  -param $1 Request authorization mode
authMode() {
    local _mode=${1:-}
    _shttp_auth_mode="$_mode"
    info "Set [Authentication-mode] with [$_shttp_auth_mode]"
}

#  Setter for '_shttp_auth_credential'.
#
#  -param $1 Request authentication
#+           credential
credential() {
    local _credential=${1:-}
    _shttp_auth_credential="$_credential"
    info "Set [Credential] with [$_shttp_auth_credential]"
}

#  Setter for '_shttp_request_times'.
#
#  -param $1 Request times
times() {
    local _times=${1:-}
    _shttp_request_times="$_times"
    info "Set [Times] with [$_shttp_request_times]"
}

#  Setter for '_shttp_editor_command'.
#
#  -param $1 Editor command
editor() {
    local _editor=${1:-}
    _shttp_editor_command="$_editor"
    info "Set [Editor] with [$_shttp_editor_command]"
}

#  Setter for '_shttp_output'.
#
#  -param $1 Output basename
output() {
    local _output=${1:-}
    _shttp_output="$_output"
    info "Set [Output] with [$_output]"
}

#  Setter for '_shttp_env'.
#
#  -param $1 Environment suffix
env() {
    local _env=${1:-}
    if [ -z "$_env" ]; then
        _shttp_suffix="default"
    else
        _shttp_suffix="$_env"
    fi
    if [ "$_env" = "default" ]; then
        _env=""
    fi
    if [ -n "$_env" ]; then
        _shttp_env="ws/config.$_env.json"
        _shttp_creds="ws/credentials.$_env.json"
    else
        _shttp_env="ws/config.json"
        _shttp_creds="ws/credentials.json"
    fi
    if ! [ -f "$_shttp_env" ]; then
        fatal "Configuration [$_shttp_env] does not exist"
    fi
    if ! [ -f "$_shttp_creds" ]; then
        fatal "Credentials [$_shttp_creds] does not exist"
    fi
    info "Set [Configuration] with [$_shttp_env]"
    info "Set [Credentials] with [$_shttp_creds]"
}

#  Explicitly sets parameters to 
#+ '_shttp_input_params' only if
#+ there are no input parameters
#+ (command is discarded in the
#+ parameters count).
#
#  -param $* Defined input parameters
mainOpts() {
    local _main_params=( $( echo "$_shttp_input_params" | tr " " "\n" ) )
    local _main_length=${#_main_params[@]}
    _main_length=$(( _main_length-1 ))
    if (( _main_length < 1 )); then
        _shttp_input_params="${*}"
    fi
}


# ---------- Mock functions

#  Set to enabled '_shttp_mock_enabled'.
mockEnabled() {
    _shttp_mock_enabled=1
    info "Set [Mock-Enabled] with [true]"
}

#  Setter for '_shttp_mock_output'
#+ file.
#
#  -param $1 Offset value
#  -param $2 Repeat option:
#+           '[0-9]+t' for times
#+           '[0-9]+s' for size
#+           in bytes
#  -param $@ Mock output parts
#  -see _append_content_file
mockOutput() {
    if ! [ -f "$_shttp_mock_output" ]; then
        _shttp_mock_output="ws/.mock-output.$( date '+%s.%N' ).json.tmp"
    fi
    _append_content_file "$_shttp_mock_output" "$@"
}

#  Setter for response HTTP
#+ status for mocked request.
#
#  -param $1 HTTP Status
mockStatus() {
    local _status=${1:-}
    if ! [ -f "$_shttp_mock_trace" ]; then
        _shttp_mock_trace="ws/.mock-trace.$( date '+%s.%N' ).json.tmp"
    fi
    echo "< http_code: $_status" | tee -a "$_shttp_mock_trace" > /dev/null
}

#  Setter for response HTTP
#+ headers for mocked request.
#_requ
#  -param $@ HTTP Headers
mockHeaders() {
    if ! [ -f "$_shttp_mock_trace" ]; then
        _shttp_mock_trace="ws/.mock-trace.$( date '+%s.%N' ).json.tmp"
    fi
    for _header in "$@"; do
        echo "< $_header" | tee -a "$_shttp_mock_trace" > /dev/null
    done
}


# ---------- Internal functions

#  Check if word exists is a
#+ key-words:
#    1. Start with 'before_'
#    2. Start with 'after_'
#
#  -param $1 Name of key-word
#  -return '1' if keyword exist
#+         otherwise '0'
_is_keyword() {
    local _name=${1:-}
    local _found=0
    case "$_name" in
        before_* | after_*)
            _found=1
        ;;
    esac
    echo $_found
}

#  Check if function is already
#+ declared.
#
#  -param $1 Function name
#  -return '1' if exist function
#+         otherwise '0'
_has_func() {
    local _func=${1:-}
    local _exists=1
    #  shellcheck disable=SC2034
    _exists=$( declare -f "$_func" > /dev/null ; echo $? )
    if (( _exists == 0 )); then
        echo 1
    else
        echo 0
    fi
}

#  Execute function if it is
#+ already declared.
#
#  -param $1 Function name
#  -param $* Parameters
_execute_if_exist() {
    local _func=${1:-}
    local _has_func=0
    shift
    _has_func=$( _has_func "$_func" )
    if (( _has_func == 1 )); then
        $_func "$@"
    fi
}

#  Execute flow lifecycle:
#    1. Set flow date
#    1. Set flow tag
#    2. Set output flow basename
#    3. Execute 'before_flow' function
#+      if it is declared
#    4. Execute 'before_<flow>' function
#+      if it is declared
#    5. Execute the flow
#    6. Execute 'after_<flow>' function
#+      if it is declared
#    7. Execute 'after_flow' function
#+      if it is declared
#    8. Save flow to history
#    9. Show assertion results
#    10. Notify flow execution
#    11. Set execution status
#    12. Reset flow variables
#  If times parameter is passed
#+ the execution will be performed
#+ for that number.
#
#  -param $1 Request flow
#  -param $2 Request flow times
#+           (positive values)
_execute_flow() {
    local _command=${1:-}
    local _times=${2:-1}
    if (( _times < 1 )); then
        _times=1
    fi
    for (( _flow_idx=1; _flow_idx<=_times; _flow_idx++ )); do
        #  Initialize output flow variables
        _shttp_date_flow=$( date '+%Y-%m-%d %T.%N %z' )
        _shttp_current_flow="$_command"
        _shttp_output_flow="$( _output_dir "$_command" )/main"
        _shttp_flow_index="$_flow_idx"
        _shttp_assertions_flow=0
        _shttp_failures_flow=0
        #  Log flow init
        info "$_flow_idx: [$_shttp_current_flow] Init flow [$_command]"
        _flow_log "$_flow_idx: [$_shttp_current_flow] Init flow [$_command]"
        #  Main flow lifecycle
        _execute_if_exist before_flow
        _execute_if_exist "before_${_command}"
        $_command "$_shttp_flow_index"
        _execute_if_exist "after_${_command}"
        _execute_if_exist after_flow
        #  Log flow end
        info "$_flow_idx: [$_shttp_current_flow] Done flow [$_command]"
        _flow_log "$_flow_idx: [$_shttp_current_flow] Done flow [$_command]"
        #  Show flow results
        info "Created $_shttp_output_flow.trace"
        _save_history "$_command" FLOW
        _assertion_results_log FLOW
        _notify_execution "$_command" FLOW
        #  Set execution status
        _shttp_status=$(( _shttp_status+_shttp_failures_flow ))
        #  Reset flow variables
        _shttp_assertions_flow=0
        _shttp_failures_flow=0
        _shttp_date_flow=""
        _shttp_current_flow=""
        _shttp_output_flow=""
    done
    _shttp_flow_index=0
}

#  Execute request lifecycle:
#    1. Set request date
#    2. Execute 'before_api' function
#+      if it is declared
#    3. Execute the command
#    4. Set request method based on
#+      command name if it was not
#+      assigned during the command
#+      execution
#    5. Execute the request
#    6. Execute 'after_api' function
#+      if it is declared
#    7. Execute open editor task
#    8. Save request to history
#    9. Show assertion results
#    10. Notify request execution
#    11. Set execution status
#    12. Reset request variables
#  If times parameter is passed
#+ the execution will be performed
#+ for that number.
#
#  -param $1 Request command
#  -param $2 Request execution times
#+           (positive values)
_execute() {
    local _command=${1:-}
    local _times=${2:-1}
    if (( _times < 1 )); then
        _times=1
    fi
    for (( _req_idx=1; _req_idx<=_times; _req_idx++ )); do
        #  Initialize request variables
        _shttp_current_request="$_command"
        _shttp_date=$( date '+%Y-%m-%d %T.%N %z' )
        _shttp_request_index="$_req_idx"
        _shttp_assertions=0
        _shttp_failures=0
        #  Log request init
        if [ "$_shttp_execution_type" = "FLOW" ]; then
            info "$_shttp_flow_index: [$_shttp_current_flow] >>> $_req_idx: Init request [$_command]"
            _flow_log "$_shttp_flow_index: [$_shttp_current_flow] >>> $_req_idx: Init request [$_command]"
        else
            info "$_req_idx: Init request [$_command]"
        fi
        #  Main request lifecycle
        _execute_if_exist before_api
        $_command "$_shttp_request_index"
        _set_method "$_command"
        _request "$_command"
        _execute_if_exist after_api
        _execute_editor_command
        #  Log request end
        if [ "$_shttp_execution_type" = "FLOW" ]; then
            info "$_shttp_flow_index: [$_shttp_current_flow] >>> $_req_idx: Done request [$_command]"
            _flow_log "$_shttp_flow_index: [$_shttp_current_flow] >>> $_req_idx: Done request [$_command]"
        else
            info "$_req_idx: Done request [$_command]"
        fi
        #  Show request results
        _save_history "$_command" REQUEST
        _assertion_results_log REQUEST
        _notify_execution "$_command" REQUEST
        #  Set execution status
        _shttp_status=$(( _shttp_status+_shttp_failures ))
        #  Reset request variables
        _reset_req_vars
        _shttp_assertions=0
        _shttp_failures=0
    done
    _shttp_current_request=""
    _shttp_date=""
    _shttp_request_index=0
}

#  Initilize request variables.
#  If the variable was set via
#+ options, the value will not
#+ change.
_reset_req_vars() {
    _shttp_url=""
    _shttp_method=""
    _shttp_base_path=""
    _shttp_endpoint=""
    _shttp_headers=()
    _shttp_body=""
    _shttp_form=()
    _shttp_query_params=()
    _shttp_curl_opts=()
    _shttp_output=""
    _shttp_protocol=""
    _shttp_domain=""
    _shttp_port=""
    _shttp_auth_credential=""
    _shttp_auth_mode=""
    _shttp_editor_command=""
    _shttp_open_editor=0
    _shttp_mock_enabled=0
    _shttp_mock_output=""
    _shttp_mock_trace=""
}

#  Put default values to empty
#+ variables. The default
#+ not null values are taken
#+ from 'ws/config[.<env>].json'.
#    1. '_shttp_protocol': 'get protocol'
#    2. '_shttp_domain': 'get domain'
#    3. '_shttp_port': 'get port'
#    4. '_shttp_base_path': 'get basePath'
#    5. '_shttp_endpoint': 'get endpoint'
#    6. '_shttp_method': 'get method'
#    7. '_shttp_auth_mode': 'get authMode'
#    8. '_shttp_auth_credential': 'get authCredential'
#    9. '_shttp_editor_command': 'get editorCommand'
#    10. '_shttp_headers': (for each in)
#+       'get headers'
#    11. '_shttp_body': (for each in)
#+       'get body'
#    12. '_shttp_form': (for each in)
#+       'get form'
#    13. '_shttp_query_params': (for each in)
#+        'get queryParams'
#    14. '_shttp_curl_opts': (for each in)
#+       'get curlOpts'
_default_config() {
    local _name=""
    local _val=""
    local _vals=()
    local _length=0
    if [ -z "$_shttp_protocol" ]; then
        _val=$( get protocol )
        if [ "$_val" != "null" ]; then protocol "$_val" ; fi
    fi
    if [ -z "$_shttp_domain" ]; then
        _val=$( get domain )
        if [ "$_val" != "null" ]; then domain "$_val" ; fi
    fi
    if [ -z "$_shttp_port" ]; then
        _val=$( get port )
        if [ "$_val" != "null" ]; then port "$_val" ; fi
    fi
    if [ -z "$_shttp_base_path" ]; then
        _val=$( get basePath )
        if [ "$_val" != "null" ]; then basePath "$_val" ; fi
    fi
    if [ -z "$_shttp_endpoint" ]; then
        _val=$( get endpoint )
        if [ "$_val" != "null" ]; then endpoint "$_val" ; fi
    fi
    if [ -z "$_shttp_method" ]; then
        _val=$( get method )
        if [ "$_val" != "null" ]; then method "$_val" ; fi
    fi
    if [ -z "$_shttp_auth_mode" ]; then
        _val=$( get authMode )
        if [ "$_val" != "null" ]; then authMode "$_val" ; fi
    fi
    if [ -z "$_shttp_auth_credential" ]; then
        _val=$( get authCredential )
       if [ "$_val" != "null" ]; then credential "$_val" ; fi
    fi
    if [ -z "$_shttp_editor_command" ]; then
        _val=$( get editorCommand )
        if [ "$_val" != "null" ]; then editor "$_val" ; fi
    fi
    _length=${#_shttp_headers[@]}
    if (( _length == 0 )); then
        _length=$( jq  '.headers | length' "$_shttp_env" )
        if (( _length > 0)); then
            _vals=( $( jq ".headers | .[]" "$_shttp_env" ) )
            for _i in "${_vals[@]}"; do headers "$_i" ; done
        fi
    fi
    if ! [ -f "$_shttp_body" ]; then
        _length=$( jq  '.body | length' "$_shttp_env" )
        if (( _length > 0)); then
            _vals=( $( jq ".body | .[]" "$_shttp_env" ) )
            for _i in "${_vals[@]}"; do body "$_i" ; done
        fi
    fi
    _length=${#_shttp_form[@]}
    if (( _length == 0 )); then
        _length=$( jq  '.form | length' "$_shttp_env" )
        if (( _length > 0)); then
            _vals=( $( jq ".form | .[]" "$_shttp_env" ) )
            for _i in "${_vals[@]}"; do form "$_i" ; done
        fi
    fi
    _length=${#_shttp_query_params[@]}
    if (( _length == 0 )); then
        _length=$( jq  '.queryParams | length' "$_shttp_env" )
        if (( _length > 0)); then
            _vals=( $( jq ".queryParams | .[]" "$_shttp_env" ) )
            for _i in "${_vals[@]}"; do queryParams "$_i" ; done
        fi
    fi
    _length=${#_shttp_curl_opts[@]}
    if (( _length == 0 )); then
        _length=$( jq  '.curlOpts | length' "$_shttp_env" )
        if (( _length > 0)); then
            _vals=( $( jq ".curlOpts | .[]" "$_shttp_env" ) )
            for _i in "${_vals[@]}"; do curlOpts "$_i" ; done
        fi
    fi
}

#  Put default values to empty
#+ variables.
#    1. '_shttp_protocol': 'https'
#    2. '_shttp_url':
#+      <protocol>://<domain><base-path><endpoint>
#    3. '_shttp_auth_mode': 'SKIP'
#    4. '_shttp_output': 
#+      'output/<main-script>.<date>'
#+      'output/flow<flow-tag>/<main-script>.<date-flow>'
#
#  -param $1 Request command
_default_vars() {
    local _command=${1:-}
    if [ -z "$_shttp_protocol" ]; then
        protocol "https"
    fi
    if [ -z "$_shttp_url" ]; then
        if [ -z "$_shttp_port" ]; then
            url "${_shttp_protocol}://${_shttp_domain}${_shttp_base_path}${_shttp_endpoint}"
        else
            url "${_shttp_protocol}://${_shttp_domain}:${_shttp_port}${_shttp_base_path}${_shttp_endpoint}"
        fi
    fi
    if [ -z "$_shttp_auth_mode" ]; then
        authMode "SKIP"
    fi
    if [ -z "$_shttp_output" ]; then
        output "$( _output_dir "$_command" )/$( date -d "$_shttp_date" '+%s.%N' )"
    fi
}

#  Generates an output directory.
#
#  -param $1 Request/Flow command
#  -return Output directory
_output_dir() {
    local _command=${1:-}
    local _output=""
    _output="output/$( basename "$0" )"
    if ! [ -d "$_output" ]; then
        mkdir "$_output"
    fi
    if [ "$_shttp_execution_type" = "FLOW" ]; then
        if [ -z "$_shttp_output_flow" ]; then
            _output="$_output/$_command"
            if ! [ -d "$_output" ]; then
                mkdir "$_output"
            fi
            _output="$_output/$( date -d "$_shttp_date_flow" '+%Y-%m-%d' )"
            if ! [ -d "$_output" ]; then
                mkdir "$_output"
            fi
            _output="$_output/$( date -d "$_shttp_date_flow" '+%s-%N' )"
            if ! [ -d "$_output" ]; then
                mkdir "$_output"
            fi
        else
            _output=${_shttp_output_flow/main/}
        fi
    else
        _output="$_output/$_command"
        if ! [ -d "$_output" ]; then
            mkdir "$_output"
        fi
        _output="$_output/$( date -d "$_shttp_date" '+%Y-%m-%d' )"
        if ! [ -d "$_output" ]; then
            mkdir "$_output"
        fi
    fi
    echo "$_output"
}

#  This lifecycle function is called
#+ for request execution:
#    1. Set default request variables
#+      using 'ws/config[.<env>].json'
#    2. Set default request variables
#    3. Execute 'before_<command>' function
#+      if it is declared
#    4. Append default 'Content-Type' to
#+      headers
#    5. Append authentication to request.
#    6. Build 'cURL' command
#    7. Execute 'cURL' command
#    8. Clean and append details into
#+      '_shttp_output.trace' file
#    9. Execute 'after_<command>' function
#+      if it is declared
#
#  -param $1 Request command
_request() {
    local _command=${1:-}
    local _curl=""
    _default_config
    _default_vars "$_command"
    _execute_if_exist "before_${_command}"
    _append_content_type
    _append_auth
    _curl=$( _build_curl BODY_FILE EXECUTABLE )
    if (( _shttp_mock_enabled == 1 )); then
        if [ -f "$_shttp_mock_output" ]; then
            mv "$_shttp_mock_output" "$_shttp_output.output"
        else
            echo "" > "$_shttp_output.output"
        fi
        if [ -f "$_shttp_mock_trace" ]; then
            mv "$_shttp_mock_trace" "$_shttp_output.trace"
        else
            echo "" > "$_shttp_output.trace"
        fi
    else
        eval "$_curl"
    fi
    _clean_trace "$_curl"
    _execute_if_exist "after_${_command}"
    printf '\n' ; cat "$_shttp_output.trace"
    printf '\n' ; cat "$_shttp_output.output"
    printf '\n\n'
    if [ -f "$_shttp_output.body" ]; then
        info "Created $_shttp_output.body"
    fi
    info "Created $_shttp_output.trace"
    info "Created $_shttp_output.output"
    if [ "$_shttp_execution_type" = "FLOW" ]; then
        _flow_log "Created $_shttp_output.trace"
        _flow_log "Created $_shttp_output.output"
    fi
}

#  This lifecycle function is called
#+ for request execution:
#    1. Look for request method at
#+      beginning of the command name.
#+      The search is case insensitive.
#+      A valid command must have the
#+      form '<verb><complement-name>',
#+      with one of these verbs: 'get',
#+      'post', 'put', 'patch', 'delete',
#+      'head' or 'options'.
#    2. If command is valid, '_shttp_method'
#+      will have the respective verb.
#
#  -param $1 Command name
_set_method() {
    if [ -z "$_shttp_method" ]; then
        local _command=${1:-}
        shopt -s nocasematch
        case "$_command" in
            get*)
                method "GET"
            ;;
            post*)
                method "POST"
            ;;
            put*)
                method "PUT"
            ;;
            patch*)
                method "PATCH"
            ;;
            delete*)
                method "DELETE"
            ;;
            head*)
                method "HEAD"
            ;;
            options*)
                method "OPTIONS"
            ;;
        esac
        shopt -u nocasematch
    fi
}

#  Look for existing header by name,
#+ if header does not exist a new
#+ entry is added to '_shttp_headers'
#+ otherwise skip assignment.
#
#  -param $1 Header name
#  -param $2 Header value
_append_if_missing_header() {
    local _name=${1:-}
    local _val=${2:-}
    shopt -s nocasematch
    local _found=0
    local _length=${#_shttp_headers[@]}
    if (( _length > 0 )); then
        for _header in "${_shttp_headers[@]}"; do
            if [[ "$_header" == "$_name:"* ]]; then
                _found=1
                break
            fi
        done
    fi
    shopt -u nocasematch
    if [ $_found = 0 ]; then
        headers "$_name: $_val"
    fi
}

#  Set value to 'Content-Type' header.
#  If '_shttp_form' has at least one value
#+ 'Content-Type' will be
#+ 'multipart/form' otherwise will be
#+ 'application/json'.
_append_content_type() {
    local _length=${#_shttp_form[@]}
    if (( _length > 0 )); then
        local _val="multipart/form-data"
    else
        local _val="application/json"
    fi
    _append_if_missing_header "Content-Type" "$_val"
}

#  Setup the authorization mode based
#+ on '_shttp_auth_mode':
#    1. BASIC: Set basic authentication
#+      type by 'cURL' options.
#+      Use from credential: 'username',
#+      'password'.
#    2. HEADER: Set authentication
#+      token by request header.
#+      Use from credential: 'token',
#+      'type'. If 'type' is not
#+      found, default value will be
#+      'token'.
#    3. QTOKEN: Set to 'URL' a
#+      token as query parameter.
#+      Use from credential: 'token',
#+      'tokenParam'. If 'tokenParam'
#+      is not found or empty, default
#+      value will be 'access_token'.
#    4. QKEYSEC: Set to 'URL' a
#+      key and secret as query parameter.
#+      Use from credential: 'key',
#+      'secret', 'keyParam' and
#+      'secretParam'. If 'keyParam' and
#+      'secretParam' are not found or
#+      empty, default value will be
#+      'key' and 'secret'.
#    5. SKIP: Skip authorization setup.
#    6. Another value: Exit script using
#+      'fatal' logging function.
_append_auth() {
    local _username=""
    local _password=""
    local _token=""
    local _type=""
    local _key=""
    local _secret=""
    local _token_param=""
    local _key_param=""
    local _secret_param=""
    case "$_shttp_auth_mode" in
        BASIC)
            _username=$( getPart username )
            _password=$( getPart password )
            if [ "$_password" = "null" ]; then
                curlOpts "--basic" "-u $_username"
            else
                eval "_password=\"$_password\""
                curlOpts "--basic" "-u $_username:$_password"
            fi
        ;;
        HEADER)
            _type=$( getPart type "token" )
            _token=$( getPart token )
            eval "_token=\"$_token\""
            _append_if_missing_header "Authorization" "$_type $_token"
        ;;
        QTOKEN)
            _token=$( getPart token )
            _token_param=$( getPart tokenParam "access_token" )
            eval "_token=\"$_token\""
            queryParams "$_token_param=$_token"
        ;;
        QKEYSEC)
            _key=$( getPart key )
            _secret=$( getPart secret )
            _key_param=$( getPart keyParam "key" )
            _secret_param=$( getPart secretParam "secret" )
            eval "_key=\"$_key\""
            eval "_secret=\"$_secret\""
            queryParams "$_key_param=$_key" "$_secret_param=$_secret"
        ;;
        SKIP)
            :
        ;;
        *)
            local _has_ext_auth=""
            _has_ext_auth=$( _has_func proceed_auth )
            if (( _has_ext_auth == 1 )); then
                proceed_auth
            else
                fatal "Invalid authorization mode [$_shttp_auth_mode]"
            fi
        ;;
    esac
}

#  Build 'cURL' command. This
#+ uses the following template:
#    'curl -X <_shttp_method> -s -v \
#+       -o "<_shttp_output>.output" \
#+       -H "<_shttp_headers[1..n]>" \
#+       -d "<_shttp_query_params[1..n]>" \
#+       -F "<_shttp_form[1..n]>" \
#+       --data-binary "@<:_shttp_body>" \
#+       <_shttp_curl_opts[1..n]> \
#+       <_shttp_url> > "<_shttp_output>.trace" 2>&1'
#
#  -param $1 Append body flag
#            BODY_FILE for add body as filename
#            BODY_CONTENT for add body as content
#  -param $2 Print command option
#            EXECUTABLE as internal command
#            PRINTABLE as legible command
#  -return cURL command as string
_build_curl() {
    local _body_opt=${1:-"BODY_FILE"}
    local _cmd_opt=${2:-"EXECUTABLE"}
    local _url="$_shttp_url"
    local _curl_src=(
        "curl -X $_shttp_method -s -v \\"
    )
    local _length=${#_shttp_headers[@]}
    if [ "$_cmd_opt" == "EXECUTABLE" ]; then
        _curl_src+=( "-o \"$_shttp_output.output\" \\" )
    fi
    if (( _length > 0 )); then
        for _header in "${_shttp_headers[@]}"; do
            _curl_src+=( "-H \"$_header\" \\" )
        done
    fi
    _length=${#_shttp_query_params[@]}
    if (( _length > 0 )); then
        _url+="?"
        for _param in "${_shttp_query_params[@]}"; do
            _url+="$_param&"
        done
        _url=${_url::-1}
    fi
    _length=${#_shttp_form[@]}
    if (( _length > 0 )); then
        for _form in "${_shttp_form[@]}"; do
            _curl_src+=( "-F \"$_form\" \\" )
        done
    fi
    if [ -f "$_shttp_body" ]; then
        mv "$_shttp_body" "$_shttp_output.body"
        if [ "$_body_opt" == "BODY_CONTENT" ]; then
            _curl_src+=( "--data '$( cat $_shttp_output.body )' \\" )
        else
            _curl_src+=( "--data-binary \"@$_shttp_output.body\" \\" )
        fi
    fi
    _length=${#_shttp_curl_opts[@]}
    if (( _length > 0 )); then
        for _opt in "${_shttp_curl_opts[@]}"; do
            _curl_src+=( "$_opt \\" )
        done
    fi
    _curl_format
    if [ "$_cmd_opt" == "EXECUTABLE" ]; then
        _curl_src+=( "-w \"@$_shttp_output.format\" \\" )
        _curl_src+=( "\"$_url\" \\" )
        _curl_src+=( "> \"$_shttp_output.trace\" 2>&1" )
    else
        _curl_src+=( "\"$_url\"" )
    fi
    echo "${_curl_src[*]}"
}

#  Create the file format
#+ for '--write-out' 'cURL'
#+ option. The filename is
#+ saved into 
#+ '_shttp_output.format'.
_curl_format() {
    local _format="\n"
    _format+="--content_type: %{content_type}\n"
    _format+="--filename_effective: %{filename_effective}\n"
    _format+="--ftp_entry_path: %{ftp_entry_path}\n"
    _format+="--http_code: %{http_code}\n"
    _format+="--response_code: %{response_code}\n"
    _format+="--http_connect: %{http_connect}\n"
    _format+="--local_ip: %{local_ip}\n"
    _format+="--local_port: %{local_port}\n"
    _format+="--num_connects: %{num_connects}\n"
    _format+="--num_redirects: %{num_redirects}\n"
    _format+="--redirect_url: %{redirect_url}\n"
    _format+="--remote_ip: %{remote_ip}\n"
    _format+="--remote_port: %{remote_port}\n"
    _format+="--size_download: %{size_download}\n"
    _format+="--size_header: %{size_header}\n"
    _format+="--size_request: %{size_request}\n"
    _format+="--size_upload: %{size_upload}\n"
    _format+="--speed_download: %{speed_download}\n"
    _format+="--speed_upload: %{speed_upload}\n"
    _format+="--ssl_verify_result: %{ssl_verify_result}\n"
    _format+="--time_appconnect: %{time_appconnect}\n"
    _format+="--time_connect: %{time_connect}\n"
    _format+="--time_namelookup: %{time_namelookup}\n"
    _format+="--time_pretransfer: %{time_pretransfer}\n"
    _format+="--time_redirect: %{time_redirect}\n"
    _format+="--time_starttransfer: %{time_starttransfer}\n"
    _format+="--time_total: %{time_total}\n"
    _format+="--url_effective: %{url_effective}\n"
    _format+="\n"
    echo "$_format" > "$_shttp_output.format"
}

#  Get a request detail file
#+ based on verbose 'cURL' file.
#  The trace file contains:
#+ request headers, response
#+ headers, 'cURL' command used,
#+ and captured variables.
#
#  -param $1 cURL command
_clean_trace() {
    #  shellcheck disable=SC2178
    local _curl=${1:-}
    #  Remove unnecessary log lines
    sed -i -e '/^[*{} ]/d' "$_shttp_output.trace" 
    #  Remove first two characters in each line
    sed -i -e 's/^..//' "$_shttp_output.trace"
    #  Append CURL command
    #  shellcheck disable=SC2128
    echo "$_curl" | tee -a "$_shttp_output.trace" > /dev/null
    rm -f "$_shttp_output.format"
}

#  Saves the execution history
#+ into JSON output files. This
#+ information must used for
#+ API monitoring.
#
#  -param $1 Request command/flow
#  -param $2 Execution type
_save_history() {
    local _command=${1:-}
    local _type=${2:-}
    local _assertions=0
    local _failures=0
    local _output=""
    local _hist=""
    case "$_type" in
        REQUEST)
            _assertions=$_shttp_assertions
            _failures=$_shttp_failures
            _output="$_shttp_output"
            local _time=""
            _time=$( getHeader time_total )
            local _entry="
                \"date\": \"$_shttp_date\",
                \"assertions\": $_shttp_assertions,
                \"failures\": $_shttp_failures,
                \"timeTotal\": $_time,"
        ;;
        FLOW)
            _assertions=$_shttp_assertions_flow
            _failures=$_shttp_failures_flow
            _output="$_shttp_output_flow"
            local _steps=""
            if [ -f "$_output.steps" ]; then
                while read -r _step; do
                    _steps+="\"$_step\","
                done < "$_output.steps"
                if [ -n "$_steps" ]; then
                    _steps=${_steps::-1}
                fi
            fi
            local _entry="
                \"date\": \"$_shttp_date_flow\",
                \"assertions\": $_shttp_assertions_flow,
                \"failures\": $_shttp_failures_flow,
                \"steps\": [ $_steps ],"
        ;;
    esac
    _hist="${_shttp_basename%.*}"
    if (( _assertions == 0 )); then
        local _status="BLANK"
    elif (( _failures == 0 )); then
        local _status="SUCCESS"
    else
        local _status="FAILED"
    fi
    if ! [ -d "hist/$_hist" ]; then
        mkdir "hist/$_hist"
    fi
    if ! [ -f "hist/$_hist/$_command.json" ]; then
        echo "{
            \"api\": \"$_hist\",
            \"command\": \"$_command\",
            \"type\": \"$_type\",
            \"data\": []
        }" > "hist/$_hist/$_command.json"
    fi
    local _failed=""
    if [ -f "$_output.failed" ]; then
        while read -r _line; do
            _failed+="\"$_line\","
        done < "$_output.failed"
        if [ -n "$_failed" ]; then
            _failed=${_failed::-1}
        fi
    fi
    _entry+="\"status\": \"$_status\","
    _entry+="\"failed\": [ $_failed ]"
    update "hist/$_hist/$_command.json" ".data+=[{ $_entry }]"
}

#  Editor command is used
#+ after request processing.
#  The design was thinking
#+ about to open request
#+ results into file
#+ editor and then process
#+ it manually.
#  Execution takes the following
#+ steps:
#    1. Replace ':OUTPUT' text for
#+      'shttp_output.output'
#+      value.
#    2. Variables resolution
#+      if any exist in the
#+      original definition.
#    3. Command execution.
_execute_editor_command() {
    if [ -n "$_shttp_editor_command" ] && [ "$_shttp_open_editor" = "1" ]; then
        if [ -s "$_shttp_output.output" ]; then
            _shttp_editor_command=${_shttp_editor_command//:OUTPUT/$_shttp_output.output}
        fi
        eval "_shttp_editor_command=\"$_shttp_editor_command\""
        info "Start [$_shttp_editor_command]"
        eval "$_shttp_editor_command"
    fi
}

#  Append content to file.
#+ Additional functionality
#+ is to repeat the content
#+ part as times as repeat
#+ or size options are passed.
#+ For repeat the content is
#+ repeated '$2' times.
#+ For size the content is
#+ repeated until content
#+ has the required size.
#  Not documented yet.
#
#  -param $1 Field file
#  -param $2 Offset value
#  -param $3 Repeat option:
#+           '[0-9]+t' for times
#+           '[0-9]+s' for size
#+           in bytes
#  -param $@ Content parts
_append_content_file() {
    local _file=${1:-}
    local _offset=0
    local _repeat=0
    local _max_size=0
    shift
    if [ $# -gt 2 ]; then
        if [[ "$1" =~ ^[0-9]+$ ]]; then
            _offset=$1
            shift
            if [[ "$1" =~ ^[0-9]+t$ ]]; then
                _repeat=$( echo "$1" | cut -d t -f 1 )
                shift
            elif [[ "$1" =~ ^[0-9]+s$ ]]; then
                _max_size=$( echo "$1" | cut -d s -f 1 )
                shift
            fi
        fi
    fi
    local _current_total=0
    if [ -f "$_file" ]; then
        _current_total=$( stat -c%s "$_file" )
    fi
    local _size=0
    if (( $# > 0 )); then
        if (( _repeat > 0 )); then
            _repeat=$(( _repeat-_offset ))
            for (( _i=1; _i<=_repeat; _i++ )); do
                for _part in "$@"; do
                    printf "%s" "$_part" | tee -a "$_file" > /dev/null
                    _size=$(( _size+${#_part}  ))
                done
            done
        elif (( _max_size > 0 )); then
            _max_size=$(( _max_size-_current_total-_offset ))
            for (( ; ; )); do
                for _part in "$@"; do
                    printf "%s" "$_part" | tee -a "$_file" > /dev/null
                    _size=$(( _size+${#_part} ))
                done
                if (( _size >= _max_size )); then
                    break
                fi
            done
        else
            for _part in "$@"; do
                printf "%s" "$_part" | tee -a "$_file" > /dev/null
                _size=$(( _size+${#_part} ))
            done
        fi
    fi
    _current_total=$(( _current_total+_size ))
    info "Appended [$_size] bytes to [$_file], total [$_current_total]"
}

#  Takes an snapshot of the
#+ execution and notify it.
#
#  -param $1 Execution type
_notify_execution() {
    local _has_ext_notif=""
    _has_ext_notif=$( _has_func proceed_notif )
    if (( _has_ext_notif == 1 )); then
        local _command=${1:-}
        local _type=${2:-}
        local _assertions=0
        local _failures=0
        local _output=""
        _notify_log "*$_command* $_shttp_execution_type"
        case "$_shttp_execution_type" in
            REQUEST)
                _notify_log "> $_shttp_method $_shttp_url"
                #  shellcheck disable=SC2119
                _notify_log "> HTTP/1.1 $( getStatus )"
                _assertions=$_shttp_assertions
                _failures=$_shttp_failures
                _output="$_shttp_output"
            ;;
            FLOW)
                _assertions+=$_shttp_assertions_flow
                _failures=$_shttp_failures_flow
                _output="$_shttp_output_flow"
                if [ -f "$_output.steps" ]; then
                    _notify_log "> "
                    _notify_log "> *Steps*"
                    while read -r _line; do
                        _notify_log "> $_line"
                    done < "$_output.steps"
                fi
            ;;
        esac
        _notify_log "> "
        if (( _assertions == 0 )); then
            local _level="BLANK"
            _notify_log "> No assertions"
        elif (( _failures == 0 )); then
            local _level="INFO"
        elif (( _assertions == _failures )); then
            local _level="ERROR"
        else
            local _level="WARNING"
        fi
        if [ "$_level" != "BLANK" ]; then
            if [ -f "$_output.failed" ]; then
                _notify_log "> *Assertions*"
                while read -r _line; do
                    _notify_log "> $_line"
                done < "$_output.failed"
            fi
        fi
        if [ "$_shttp_execution_type" = "$_type" ]; then
            _hd "$_shttp_output.notif"
            local _message=""
            _message=$( < "$_shttp_output.notif" )
            proceed_notif "$_level" "$_message"
        fi
        rm -f "$_shttp_output.notif"
    fi
}

#  Mask secret values of
#+ specified content file.
#
#  -param $* File
_hd() { local _file=${1:-} ; if [ -a "ws/.vlt" ]; then while read -r _h; do
    _h=$( echo "$_h" | cut -d '!' -f 2 | base64 --decode )
    _h=${_h//\//\\/} ; sed -i -- "s/$_h/*****/g" "$_file"
    done < "ws/.vlt" ; fi ; }

#  Show assertion results if
#+ assetion count is greater
#+ than '0'.
#  No test required.
#
#  -param $1 Execution type
_assertion_results_log() {
    local _type=${1:-}
    local _assertions=0
    local _failures=0
    local _output=""
    case "$_shttp_execution_type" in
        REQUEST)
            _assertions=$_shttp_assertions
            _failures=$_shttp_failures
            _output="$_shttp_output"
        ;;
        FLOW)
            _assertions=$_shttp_assertions_flow
            _failures=$_shttp_failures_flow
            _output="$_shttp_output_flow"
        ;;
    esac
    if [ "$_shttp_execution_type" = "$_type" ]; then
        if (( _assertions > 0 )); then
            if [ -f "$_output.failed" ]; then
                info "Created $_output.failed"
                while read -r _line; do
                    info ">>> $_line"
                done < "$_output.failed"
            fi
            if [ $_failures = 0 ]; then
                info "[PASSED] - [$_assertions] of [$_assertions] assertions passed"
            else
                warn "[FAILED] - [$_failures] of [$_assertions] assertions failed"
            fi
        fi
    fi
}

#  Log a message about flow
#+ processing into
#+ '_shttp_output_flow.trace'.
#  No test required.
#
#  -param $* Log message
_flow_log() {
    echo "$( date '+%Y-%m-%d %T.%N' ) [FLOW]   $*" | tee -a "$_shttp_output_flow.trace" > /dev/null
}

#  Log a message about assertion
#+ failed into '_shttp_output.failed'.
#  No test required.
#
#  -param $* Log message
_failed_log() {
    if [ "$_shttp_execution_type" = "FLOW" ]; then
        echo "$_shttp_current_request: $*" | tee -a "$_shttp_output_flow.failed" > /dev/null
        echo "$*" | tee -a "$_shttp_output.failed" > /dev/null
    else
        echo "$*" | tee -a "$_shttp_output.failed" > /dev/null
    fi
}

#  Log a notification.
#  No test required.
#
#  -param $* Log message
_notify_log() {
    echo "$*" | tee -a "$_shttp_output.notif" > /dev/null
}

#  Cleanup all temp JSON files from
#+ workspace and hide private
#+ data to log files.
#  This function is called after
#+ execute the main code or after
#+ get an error.
#  No test required.
#
#  -param $? Exit code
_finally_http_api() {
    local _code=$?
    (
        if [ -d ws ]; then
            rm -f ws/.*.json.tmp &
        fi
        if [ -d output ]; then
            find . -name "*.format" -delete
            find . -type d -empty -delete
        fi
        if [ "$SAVED_LOGS" == "true" ]; then
            _hd "$_shttp_log_file"
        fi
    ) &
    if [ $_shttp_status = 0 ]; then
        exit 0
    elif [ $_code != 0 ]; then
        exit $_code
    else
        exit 1
    fi
}

#  Execute finally function and
#+ exit the program.
#  No test required.
_exit() {
    _finally_http_api
    exit 0
}


# ---------- Option functions

#  Look for parameters belong
#+ to option. Parameters are
#+ collected and they are sent
#+ to a 'callback' function.
#+ The 'callback' is collected
#+ from '_shttp_registered_opts'.
#  Search is interrupted
#+ if another option is found
#+ in the parameters.
#  Valid options have the form:
#+ '--<option>'.
#
#  -param $1 Looked option
#  -param $* Input parameters
_look_for_params() {
    local _opt=${1:-}
    local _params=( "$_opt" )
    local _found=0
    local _length=0
    local _callback=""
    shift
    for _param in "$@"; do
        if [ $_found = 1 ]; then
            if [[ "$_param" == "--"* ]]; then
                _length=${#_params[@]}
                _callback=${_shttp_registered_opts[$_opt]}
                if (( _length > 0 )); then
                    $_callback "${_params[@]}"
                else
                    $_callback
                fi
                #  Executed flag
                _found=2
                _params=( "$_opt" )
            else
                _params+=( "$_param" )
            fi
        fi
        if [ "$_param" = "$_opt" ]; then
            #  Found flag
            _found=1
        fi
    done
    if [ $_found = 1 ]; then
        _length=${#_params[@]}
        _callback=${_shttp_registered_opts[$_opt]}
        if (( _length > 0 )); then
            $_callback "${_params[@]}"
        else
            $_callback
        fi
    fi
    if (( _found > 0 )); then
        return 0
    else
        return 1
    fi
}

#  Register an option to
#+ '_shttp_request_opts' and
#+ '_shttp_registered_opts'.
#  The '_look_for_params'
#+ function requires the
#+ options registered by
#+ function in order to
#+ find out the correct
#+ callback function.
#
#  -param $1 Option
#  -param $2 Callback function
#  -param $3 Request option type:
#+           [REQUEST | MANAGE]
_register_opt() {
    local _option=${1:-}
    local _callback=${2:-}
    local _is_req_opt=${3:-"MANAGE"}
    _shttp_registered_opts[$_option]="$_callback"
    if [ "$_is_req_opt" = "REQUEST" ]; then
        _shttp_request_opts+=( "$_option" )
    fi
}

#  Add help lines to
#+ '_shttp_help_content'.
#
#  -param $* Help content
_help_content() {
    if (( $# > 0 )); then
        for _help in "$@"; do
            _shttp_help_content+=( "$_help" )
        done
    fi
}

#  Set the configuration environment
#+ suffix. This value will be used
#+ for get current configuration
#+ append it to 'ws/config-<env>.json'.
#
#  -param $1 Option
#  -param $2 Environment suffix
_set_env() {
    local _opt=${1:-}
    local _env=${2:-}
    env "$_env"
}
_register_opt --env _set_env REQUEST
if expr "$*" : ".*--env\s" > /dev/null; then
    _look_for_params --env "$@"
fi

#  Set the credential for script.
#
#  -param $1 Option
#  -param $2 Credential identifier
_set_credential() {
    local _opt=${1:-}
    local _credential=${2:-}
    credential "$_credential"
}
_register_opt --cred _set_credential REQUEST
if expr "$*" : ".*--cred\s" > /dev/null; then
    _look_for_params --cred "$@"
fi

#  Add a new variable, into script,
#+ which will be taken as priority
#+ config for 'get' function.
#
#  -param $1 Option
#  -param $2 Name of the entry
#  -param $3 Value of the entry
_set_config() {
    local _opt=${1:-}
    local _name=${2:-}
    local _val=${3:-}
    update "ws/.override.json.tmp" ". + { \"$_name\": $_val }"
    info "Set temporal [$_name] with value [$_val]"
}
_register_opt --set _set_config REQUEST
if expr "$*" : ".*--set\s" > /dev/null; then
    _look_for_params --set "$@"
fi

#  Set '_shttp_domain' to 'localhost'.
#+ Default port is 8080 but it can be
#+ specified as first parameter and
#+ will override default port.
#  Protocol is changed as well and takes
#+ 'http' as value.
#
#  -param $1 Option
#  -param $2 Port value
_set_localhost() {
    local _opt=${1:-}
    local _port=${2:-"8080"}
    protocol "http"
    domain "localhost"
    port "$_port"
}
_register_opt --local _set_localhost REQUEST
if expr "$*" : ".*--local" > /dev/null; then
    _look_for_params --local "$@"
fi

#  Set value to '_shttp_port'.
#
#  -param $1 Option
#  -param $2 Port value
_set_port() {
    local _opt=${1:-}
    local _port=${2:-}
    port "$_port"
}
_register_opt --port _set_port REQUEST
if expr "$*" : ".*--port\s" > /dev/null; then
    _look_for_params --port "$@"
fi

#  Set credential to '_shttp_auth_credential'.
#
#  -param $1 Option
#  -param $2 Credential identifier
_set_auth_mode() {
    local _opt=${1:-}
    local _credential=${2:-}
    local _mode=${_opt/--auth-/}
    _mode=${_mode^^}
    authMode "$_mode"
    credential "$_credential"
}
_register_opt --auth-basic _set_auth_mode REQUEST
if expr "$*" : ".*--auth-basic\s" > /dev/null; then
    _look_for_params --auth-basic "$@"
fi

_register_opt --auth-header _set_auth_mode REQUEST
if expr "$*" : ".*--auth-header\s" > /dev/null; then
    _look_for_params --auth-header "$@"
fi

_register_opt --auth-qtoken _set_auth_mode REQUEST
if expr "$*" : ".*--auth-qtoken\s" > /dev/null; then
    _look_for_params --auth-qtoken "$@"
fi

_register_opt --auth-qkeysec _set_auth_mode REQUEST
if expr "$*" : ".*--auth-qkeysec\s" > /dev/null; then
    _look_for_params --auth-qkeysec "$@"
fi

_register_opt --auth-skip _set_auth_mode REQUEST
if expr "$*" : ".*--auth-skip\s" > /dev/null; then
    _look_for_params --auth-skip "$@"
fi

#  Set request execution times
#+ to '_shttp_request_times'.
#
#  -param $1 Option
#  -param $2 Repeat times
_set_times() {
    local _opt=${1:-}
    local _times=${2:-}
    times "$_times"
}
_register_opt --times _set_times REQUEST
if expr "$*" : ".*--times\s" > /dev/null; then
    _look_for_params --times "$@"
fi

#  Set open editor flag to
#+ true: 1.
#
#  -param $1 Option
_set_open_flag() {
    local _opt=${1:-}
    _shttp_open_editor=1
}
_register_opt --open _set_open_flag REQUEST
if expr "$*" : ".*--open" > /dev/null; then
    _look_for_params --open "$@"
fi

#  Set enabled request mock.
#
#  -param $1 Option
_enable_mock() {
    local _opt=${1:-}
    mockEnabled
}
_register_opt --mock _enable_mock REQUEST
if expr "$*" : ".*--mock" > /dev/null; then
    _look_for_params --mock "$@"
fi

#  List the names of main script
#+ functions. Names contained
#+ in the 'keywords' are discarded.
#
#  -param $1 Option
#  -return Command list
_list_commands() {
    local _opt=${1:-}
    local _functions=(
        $( declare -F -p | cut -d " " -f 3 | tr " " "\n" )
    )
    local _length=${#_functions[@]}
    if (( _length > 0 )); then
        for _function in "${_functions[@]}"; do
            local _is_key=0
            _is_key=$( _is_keyword "$_function" )
            if grep -e "${_function}\s*()" "$0" > /dev/null \
                    && [[ "$_function" != "_"* ]] \
                    && (( _is_key == 0 )); then
                echo "$_function"
            fi
        done
    fi
}
_register_opt --list _list_commands MANAGE
if expr "$*" : ".*--list" > /dev/null; then
    _look_for_params --list "$@"
    _exit
fi

#  List the environment IDs based
#+ on configuration files.
#
#  -param $1 Option
#  -return Environments IDs
_get_envs() {
    local _opt=${1:-}
    local _configs=(
        $( find ws -name "config*.json" )
    )
    local _length=${#_configs[@]}
    if (( _length > 0 )); then
        for _config in "${_configs[@]}"; do
            _config=${_config/ws\/config/}
            _config=${_config/json/}
            _config=${_config//\./}
            if [ -z "$_config" ]; then
                echo "default"
            else
                echo "$_config"
            fi
        done
    fi
}
_register_opt --envs _get_envs MANAGE
if expr "$*" : ".*--envs" > /dev/null; then
    _look_for_params --envs "$@"
    _exit
fi

#  Copy the configuration and credentials
#+ files. The 'from' files must exist. If
#+ 'to' files already exist those will be
#+ replaced with new ones.
#
#  -param $1 Option
#  -param $2 From environment
#  -param $3 To environment
_copy_env() {
    local _opt=${1:-}
    local _from=${2:-}
    local _to=${3:-}
    if [ -z "$_to" ]; then
        fatal "Required argument [to] for copy"
    fi
    if [ "$_from" = "$_to" ]; then
        fatal "Parameters are the same [$_from = $_to]"
    fi
    if [ "$_from" = "default" ]; then
        _from=""
    else
        _from=".$_from"
    fi
    if [ "$_to" = "default" ]; then
        _to=""
    else
        _to=".$_to"
    fi
    if ! [ -f "ws/config$_from.json" ]; then
        fatal "File [ws/config$_from.json] does not exist"
    fi
    if ! [ -f "ws/credentials$_from.json" ]; then
        fatal "File [ws/credentials$_from.json] does not exist"
    fi
    if [ -f "ws/config$_to.json" ]; then
        rm -f "ws/config$_to.json"
        info "Deleted [ws/config$_to.json] file"
    fi
    if [ -f "ws/credentials$_to.json" ]; then
        rm -f "ws/credentials$_to.json"
        info "Deleted [ws/credentials$_to.json] file"
    fi
    cp "ws/config$_from.json" "ws/config$_to.json"
    cp "ws/credentials$_from.json" "ws/credentials$_to.json"
    info "Added [ws/config$_to.json] file"
    info "Added [ws/credentials$_to.json] file"
}
_register_opt --copy _copy_env MANAGE
if expr "$*" : ".*--copy\s" > /dev/null; then
    _look_for_params --copy "$@"
    _exit
fi

#  Remove the configuration and credentials
#+ files for specified environment.
#
#  -param $1 Option
#  -param $2 Environment suffix
_del_env() {
    local _opt=${1:-}
    local _env=${2:-}
    if [ "$_env" = "default" ]; then
        _env=""
    else
        _env=".$_env"
    fi
    if ! [ -f "ws/config$_env.json" ]; then
        fatal "File [ws/config$_env.json] does not exist"
    fi
    if ! [ -f "ws/credentials$_env.json" ]; then
        fatal "File [ws/credentials$_env.json] does not exist"
    fi
    rm -f "ws/config$_env.json"
    rm -f "ws/credentials$_env.json"
    info "Deleted [ws/config$_env.json] file"
    info "Deleted [ws/credentials$_env.json] file"
}
_register_opt --del _del_env MANAGE
if expr "$*" : ".*--del\s" > /dev/null; then
    _look_for_params --del "$@"
    _exit
fi

#  Save key-value to 'ws/config[.<env>].json'
#+ using 'put' function.
#
#  -param $1 Option
#  -param $2 Name of the entry
#  -param $3 Value of the entry
#  -param $4 Secure type
#            -h: hidden mode
#            -s: public mode
_add_config() {
    local _opt=${1:-}
    local _name=${2:-}
    local _val=${3:-}
    local _sec_type=${4:-}
    case "$_sec_type" in
        -h)
            _sec_type="PRIVATE"
        ;;
        *)
            _sec_type="PUBLIC"
        ;;
    esac
    put "$_name" "$_val" "$_sec_type"
}
_register_opt --add _add_config MANAGE
if expr "$*" : ".*--add\s" > /dev/null; then
    _look_for_params --add "$@"
    _exit
fi

#  Get key-value from 'ws/config[.<env>].json'
#+ using 'get' function.
#
#  -param $1 Option
#  -param $2 Name of the entry
#  -return Value of the entry
_get_config() {
    local _opt=${1:-}
    local _name=${2:-}
    local _val=""
    if [ -n "$_name" ]; then
        _val=$( get "$_name" )
    fi
    echo "$_val"
}
_register_opt --get _get_config MANAGE
if expr "$*" : ".*--get\s" > /dev/null; then
    _look_for_params --get "$@"
    _exit
fi

#  Remove key-value to 'ws/config[.<env>].json'
#+ using 'remove' function.
#
#  -param $1 Option
#  -param $1 Name of the entry
_remove_config() {
    local _opt=${1:-}
    local _name=${2:-}
    remove "$_name"
}
_register_opt --remove _remove_config MANAGE
if expr "$*" : ".*--remove\s" > /dev/null; then
    _look_for_params --remove "$@"
    _exit
fi

#  List the keys of 'ws/config[.<env>].json'.
#
#  -param $1 Option
#  -return 'ws/config[.<env>].json' keys
_get_config_keys() {
    local _opt=${1:-}
    local _keys=(
        $( jq "keys | .[]" "$_shttp_env" )
    )
    local _length=${#_keys[@]}
    if (( _length > 0 )); then
        for _key in "${_keys[@]}"; do
            echo "$_key" | sed -e 's/^"//' -e 's/"$//'
        done
    fi
}
_register_opt --keys _get_config_keys MANAGE
if expr "$*" : ".*--keys" > /dev/null; then
    _look_for_params --keys "$@"
    _exit
fi

#  Add credential part.
#
#  -param $1 Option
#  -param $2 Part name or value
#            -u: username
#            -p: password
#            -k: key
#            -s: secret
#            -t: token
#            -i: pin
#  -param $3 Part value
#  -param $4 Secure type:
#            -h: hidden mode
#            -s: public mode
_add_part() {
    local _opt=${1:-}
    local _part=${2:-}
    local _val=${3:-}
    local _sec_type=${4:-}
    case "$_part" in
        -u)
            _part="username"
        ;;
        -p)
            _part="password"
        ;;
        -k)
            _part="key"
        ;;
        -s)
            _part="secret"
        ;;
        -t)
            _part="token"
        ;;
        -i)
            _part="pin"
        ;;
    esac
    case "$_sec_type" in
        -s)
            _sec_type="PUBLIC"
        ;;
        *)
            _sec_type="PRIVATE"
        ;;
    esac
    putPart "$_part" "$_val" "$_sec_type"
}
_register_opt --part _add_part MANAGE
if expr "$*" : ".*--part\s" > /dev/null; then
    _look_for_params --part "$@"
    _exit
fi

#  List the credential IDs from
#+ 'ws/credentials[.<env>].json'.
#
#  -param $1 Option
#  -return 'ws/credentials[.<env>].json' ids
_get_cred_ids() {
    local _opt=${1:-}
    local _ids=(
        $( jq ".[] | .id" "$_shttp_creds" )
    )
    local _length=${#_ids[@]}
    if (( _length > 0 )); then
        for _id in "${_ids[@]}"; do
            echo "$_id" | sed -e 's/^"//' -e 's/"$//'
        done
    fi
}
_register_opt --creds _get_cred_ids MANAGE
if expr "$*" : ".*--creds" > /dev/null; then
    _look_for_params --creds "$@"
    _exit
fi

#  List the keys from
#+ 'ws/credentials[.<env>].json'.
#
#  -param $1 Option
#  -param $2 Credential
#  -return 'ws/credentials[.<env>].json' keys
_get_cred_keys() {
    local _opt=${1:-}
    local _cred=${2:-}
    local _keys=(
        $( jq ".[] | select(.id==\"$_cred\") | keys | .[]" "$_shttp_creds" )
    )
    local _length=${#_keys[@]}
    if (( _length > 0 )); then
        for _key in "${_keys[@]}"; do
            echo "$_key" | sed -e 's/^"//' -e 's/"$//'
        done
    fi
}
_register_opt --cred-keys _get_cred_keys MANAGE
if expr "$*" : ".*--cred-keys\s" > /dev/null; then
    _look_for_params --cred-keys "$@"
    _exit
fi

#  Clean all files from 'output'
#+ directory.
#
#  -param $1 Option
_clean_output_files() {
    local _opt=${1:-}
    if [ -d output ]; then
        declare -a _selected=(
            $( find "output" -name "*" -type f )
        )
         local _length=${#_selected[@]}
        if (( _length > 0 )); then
            for _file in "${_selected[@]}"; do
                info "Removed [$_file] output"
            done
            rm -rf output/*
            info "Cleaning completed"
        else
            info "Output directory is empty"
        fi
    fi
}
_register_opt --clean _clean_output_files MANAGE
if expr "$*" : ".*--clean" > /dev/null; then
    _look_for_params --clean "$@"
    _exit
fi


# ---------- Add-ons

#  Add-on files.
#  Filename must have
#+ the form: '<name>_ext'
declare -a _shttp_add_ons=(
    $( find . -name "*_ext" -type f )
)

#  Add-on files length.
readonly _shttp_add_ons_length=${#_shttp_add_ons[@]}

#  If exists add-on files
#+ they will be sourced.
if (( _shttp_add_ons_length > 0 )); then
    for _add_on in "${_shttp_add_ons[@]}"; do
        eval ". $_add_on"
        info "Add-on [$_add_on] sourced"
    done
else
    info "No add-ons sourced"
fi


# ---------- cURL content

#  Show the 'cURL' command.
#
#  -param $1 Option
#  -param $2 Body option
#  -param $3 Return variable
#  -return cURL command
_show_curl() {
    local _opt=${1:-}
    local _part=${2:-}
    local _return_var=${3:-}
    local _body_opt=""
    local _curl_value=""
    case "$_part" in
        -f)
            _body_opt="BODY_FILE"
        ;;
        *)
            _body_opt="BODY_CONTENT"
        ;;
    esac
    _execute_if_exist before_api
    $_shttp_command
    _set_method "$_shttp_command"
    _default_config
    _default_vars "$_shttp_command"
    _execute_if_exist "before_${_shttp_command}"
    _append_content_type
    _append_auth
    _shttp_output="output/curl.tmp"
    _curl_value=$( _build_curl $_body_opt PRINTABLE )
    if [ -n "$_return_var" ]; then
        eval "$_return_var='$_curl_value'"
    else
        echo "$_curl_value"
    fi
}
_register_opt --curl _show_curl MANAGE
if expr "$*" : ".*--curl" > /dev/null; then
    _shttp_command=${1:-}
    if [[ "$_shttp_command" == "--"* ]]; then
        _shttp_command=""
    fi
    if [ -z "$_shttp_command" ]; then
        info "No command to execute"
    else
        _look_for_params --curl "$@"
    fi
    _exit
fi


# ---------- Help content

#  Show the help content.
_show_help_content() {
    echo "${_shttp_help_content[*]}"
}
if expr "$*" : ".*--help" > /dev/null; then
    _show_help_content
    _exit
fi


# ---------- Main

#  Skip main code flag
readonly _shttp_skip=${SKIP_HTTP_API:-}

#  Main code:
#    1. Get the 'command' input.
#    2. Set the exist 'main' function flag.
#    3. Discard 'command' if has 'option'
#+      format.
#    4. If 'command' or 'main' is present,
#+      execute request lifecycle: '_execute'.
#    5. Finally function is executed.
if [ "$_shttp_skip" != "true" ]; then
    trap _finally_http_api EXIT
    _shttp_command=${1:-}
    _has_shttp_main=$( _has_func main )
    if [[ "$_shttp_command" == "--"* ]]; then
        _shttp_command=""
    fi
    if [ -z "$_shttp_command" ]; then
        info "No command to execute"
    elif [[ "$_shttp_command" == "flow"* ]]; then
        _shttp_execution_type="FLOW"
        _execute_flow "$_shttp_command" "$_shttp_request_times"
    elif (( _has_shttp_main == 1 )); then
        _shttp_execution_type="REQUEST"
        _execute main "$_shttp_request_times"
    else
        _shttp_execution_type="REQUEST"
        _execute "$_shttp_command" "$_shttp_request_times"
    fi
fi
