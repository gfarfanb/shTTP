#! /usr/bin/env bash
#  Simple HTTP API development environment.
#  -author Giovanni Farf√°n B.
set -euo pipefail
IFS=$'\n\t'

#  Show the help content.
_shttp_help_content() {
    local _content=(
        ""
        " Usage: ./<file>.sh <command> [--list] [--copy <from> <to>] [--get <key-name>] [--add <key-name> <value>]"
        "                              [--remove <key-name>] [--keys] [--clean]"
        ""
        "                              [--env <env>]  [--set <key-name> <value>] [--local <port>]"
        "                              [--auth-basic] [--auth-header] [--auth-qparam] [--auth-skip]"
        "                              [--times <value>] [--open]"
        ""
        "                              [--help]"
        ""
        " Manage options:"
        "   --list:                      Display the <command> list (all functions defined into main script)"
        "   --copy <env-from> <env-to>:  Copy the environment configuration and credentials files. Must exist the 'from'"
        "                                  configuration files. If already exist the 'to' files those will be replaced."
        "                                  If is required to copy from 'default' the first parameters must contain 'default'"
        "   --get <key-name>:            Display the value for key from 'ws/config[.<env>].json'"
        "   --add <key-name> <value>:    Add new key-value to 'ws/config[.<env>].json'"
        "   --remove <key-name>:         Remove the key-value from 'ws/config[.<env>].json'"
        "   --keys:                      Display all keys from 'ws/config[.<env>].json' file"
        "   --clean:                     Clean up all output files 'output/*'"
        ""
        " Request options:"
        "   --env <env>:                 Set the environment for script by changing configuration and credentials files:"
        "                                  'ws/config[.<env>].json' and 'ws/credentials[.<env>].json'"
        "   --set <key-name> <value>:    Set a temporal key-value config. This won't saved to 'ws/config[.<env>].json'"
        "   --local <port>:              Set variables to local execution:"
        "                                  _shttp_protocol: http"
        "                                  _shttp_domain: localhost:<port> (default 8080)"
        "   --auth-basic <credential>:   Set 'BASIC' mode to '_shttp_auth_mode'."
        "   --auth-header <credential>:  Set 'HEADER' mode to '_shttp_auth_mode'."
        "   --auth-qparam <credential>:  Set 'QPARAM' mode to '_shttp_auth_mode'."
        "   --auth-skip:                 Set 'SKIP' mode to '_shttp_auth_mode'."
        "   --times <value>:             Set the number of executions required for the request into '_shttp_request_times'"
        "   --open:                      Set '_shttp_editor_command' with value defined on 'editorCommand'"
        "                                  from 'ws/config[.<env>].json'. This causes to execute '_shttp_editor_command'"
        " Manual options:"
        "   --help:                      Display this help message"
    )
    echo "${_content[*]}"
}
expr "$*" : ".*--help" > /dev/null \
    && _shttp_help_content \
    && exit 0


#  Script filename.
readonly _shttp_basename=$( basename "$0" )


# ---------- Logging functions

#  Log filename.
readonly _shttp_log_file="/tmp/shTTP_${_shttp_basename%.*}.$( date '+%Y-%m-%d' ).log"

#  Log a message with the INFO level.
#
#  -param $* Log message
info() { echo "$( date '+%Y-%m-%d %T.%N' ) [INFO]    $*" | tee -a "$_shttp_log_file" >&2 ; }

#  Log a message with the WARNING level.
#
#  -param $* Log message
warning() { echo "$( date '+%Y-%m-%d %T.%N' ) [WARNING] $*" | tee -a "$_shttp_log_file" >&2 ; }

#  Log a message with the ERROR level.
#
#  -param $* Log message
error() { echo "$( date '+%Y-%m-%d %T.%N' ) [ERROR]   $*" | tee -a "$_shttp_log_file" >&2 ; }

#  Log a message with the FATAL level, 
#+ exit execution with 1.
#
#  -param $* Log message
fatal() { echo "$( date '+%Y-%m-%d %T.%N' ) [FATAL]   $*" | tee -a "$_shttp_log_file" >&2 ; exit 1 ; }


# ---------- Initialization

# 'cURL' is required
readonly _curl_version=$( curl --version )
if [ -z "$_curl_version" ]; then
    fatal "'curl' is not installed yet"
fi

#  'jq' (command-line JSON processor) is required
#+ https://github.com/stedolan/jq
readonly _jq_version=$( jq --version )
if [ -z "$_jq_version" ]; then
    fatal "'jq' is not installed yet"
fi

#  Output directory for trace and results files
if ! [ -d output ]; then 
    mkdir output || fatal "Imposible to create 'output' dorectory"
fi

#  Workspace directory for data execution
if ! [ -d ws ]; then 
    mkdir ws || fatal "Imposible to create 'ws' dorectory"
fi

#  Default configuration JSON file
if ! [ -f "ws/config.json" ]; then
    echo '{
        "protocol": null,
    	"domain": null,
    	"basePath": null,
    	"endpoint": null,
    	"method": null,
    	"headers": [],
    	"body": [],
    	"form": [],
    	"queryParams": [],
    	"curlOpts": [],
    	"authMode": null,
    	"authCredential": null,
    	"editorCommand": null
    }' > "ws/config.json"
fi

#  Default credentials JSON file
if ! [ -f "ws/credentials.json" ]; then
    echo '[{
        "id": "Mandatory",
        "username": "Mandatory for: BASIC",
        "password": "Optional for: BASIC. Evaluated it during request.",
        "secret": "Mandatory for: BEARER, QPARAM. Evaluated it during request.",
        "type": "Optional for: BEARER, QPARAM"
    }]' > "ws/credentials.json"
fi

#  Override JSON file
if [ -f "ws/override.json.tmp" ]; then
    rm -f "ws/override.json.tmp"
fi
echo '{ }' > "ws/override.json.tmp"


# ---------- Util functions

#  Reverse the string input.
#
#  -param $1 String input
#  -return Reversed string
_rev() {
    local _input=${1:-''}
    local _rev=""
    for (( i=${#_input}-1; i>=0; i-- )); do 
        _rev="$_rev${_input:$i:1}"
    done
    echo "$_rev"
}


# ---------- Public functions

#  Request flow step. Simulate
#+ and external request call:
#+ input parameters processing,
#+ and request execution.
#  It is recommended to use
#+ inside a flow function.
#  This is the step process:
#    1. Execute option functions
#+      based on input parameters.
#    2. Execute request command.
#    3. Reset request variables.
#
#  -param $1 Request command
#  -param $@ Request options
step() {
    local _command=${1:-''}
    shift
    _shttp_input_params="${*}"
    for _opt in "${_shttp_request_opts[@]}"; do
        _look_for_params "$_opt" "$@" || continue
    done
    _execute "$_command" "$_shttp_request_times"
    _shttp_input_params=""
    _shttp_request_times=0
    _shttp_assertions=0
    _shttp_failures=0
    _init_vars
}

#  Update a JSON file using 'jq'.
#
#  -param $1 JSON file
#  -param $2 Change by 'jq'
update() {
    local _json=${1:-''}
    local _jq=${2:-''}
    local _temp=""
    _temp="ws/pivot.$( date '+%s.%N' ).json.tmp"
    < "$_json" jq "$_jq" > "$_temp"
    mv "$_temp" "$_json"
    info "Updated [$_json] file"
}

#  Save key-value config to 'ws/config[.<env>].json'.
#  This function has three different forms:
#    1. Only 'jq' query: put '.jq'
#    2. Name and 'jq' query: put 'name' '.jq'
#    3. Name and value: put 'name' 'value'
#  If 'jq' query is found, the function will
#+ use JSON result to take the value.
#
#  -param $1 Name of the entry or 'jq' for value
#  -param $2 Value of the entry or 'jq' for value
put() {
    local _name=${1:-''}
    local _val=${2:-''}
    local _jq=""
    if [ -z "$_val" ]; then
        _jq="$_name"
        _name=${_name//[0-9^\[\]]/}
        _name=$( _rev "$_name" )
        _name=$( echo "$_name" | cut -d '.' -f 1 )
        _name=$( _rev "$_name" )
    elif [[ "$_val" = \.* ]]; then
        _jq="$_val"
    fi
    if [ -n "$_jq" ]; then
        _val=$( < "$_shttp_output.output" jq "try $_jq catch null" )
    fi
    update "$_shttp_env" ". + { \"$_name\": $_val }"
    info "Saved [$_name] with value [$_val] to workspace config"
}

#  Get key-value config in the following
#+ order: script variables and then from
#+ 'ws/config[.<env>].json'.
#
#  -param $1 Name of the entry or 'jq'
#+           query (without '.' at the
#+           beginning of the query)
#  -param $2 Default value if required
#+           is not found. If it is not
#+           specified 'null' will be
#+           default value.
#  -return Config value
get() {
    local _name=${1:-''}
    local _default=${2:-'null'}
    local _val=""
    _val=$( < "ws/override.json.tmp" jq ".$_name | tostring" )
    _val=$( echo "$_val" | sed -e 's/^"//' -e 's/"$//' )
    if [ "$_val" = "null" ]; then
        _val=""
    fi
    if [ -z "$_val" ]; then
        _val=$( jq ".$_name | tostring" "$_shttp_env" )
        _val=$( echo "$_val" | sed -e 's/^"//' -e 's/"$//' )
        if [ "$_val" = "null" ]; then
            _val="$_default"
        fi
    fi
    echo "$_val"
}

#  Remove key-value from 'ws/config[.<env>].json'.
#  This function has two different forms:
#    1. 'jq' query: remove '.jq'
#    2. Field name: remove 'name'
#
#  -param $1 Name of the entry
remove() {
    local _name=${1:-''}
    if [[ "$_name" = \.* ]]; then
        local _val=""
        _val=$( jq "try $_name catch null" "$_shttp_env" )
        if [ "$_val" != "null" ]; then
            update "$_shttp_env" "del($_name)"
            info "Removed [$_name] from workspace config"
        fi
    else
        local _found=""
        _found=$( jq "has(\"$_name\")" "$_shttp_env" )
        if [ "$_found" = "true" ]; then
            update "$_shttp_env" "del(.$_name)"
            info "Removed [$_name] from workspace config"
        fi
    fi
}

#  Get JSON value from
#+ '$_shttp.output.output'.
#
#  -param $1 Name of the entry or 'jq'
#+           query (without '.' at the
#+           beginning of the query)
#  -param $2 Default value if required
#+           is not found. If it is not
#+           specified 'null' will be
#+           default value.
#  -return JSON value
getOutput() {
    local _name=${1:-''}
    local _default=${2:-'null'}
    local _val=""
    _val=$( < "$_shttp_output.output" jq ".$_name | tostring" )
    _val=$( echo "$_val" | sed -e 's/^"//' -e 's/"$//' )
    if [ "$_val" = "null" ]; then
        _val="$_default"
    fi
    echo "$_val"
}

#  Asserts that a given 'Bash Conditional
#+ Expressions' is true.
#
#  -param $1 Fail message
#  -param $2 Condition content:
#+           '[ <$2> ]'
isTrue() {
    local _message=${1:-''}
    local _condition=${2:-''}
    local _ok=1
    eval "if ! [ $_condition ]; then _ok=0 ; fi"
    if [ $_ok = 0 ]; then
        _shttp_failures=$(( _shttp_failures+1 ))
        _shttp_failures_flow=$(( _shttp_failures_flow+1 ))
        _assertion_log "[ $_condition ]: $_message"
    fi
    _shttp_assertions=$(( _shttp_assertions+1 ))
    _shttp_assertions_flow=$(( _shttp_assertions_flow+1 ))
}

#  Asserts that a given 'Bash Conditional
#+ Expressions' is false.
#
#  -param $1 Fail message
#  -param $2 Condition content:
#+           '! [ <$2> ]'
isFalse() {
    local _message=${1:-''}
    local _condition=${2:-''}
    local _ok=1
    eval "if [ $_condition ]; then _ok=0 ; fi"
    if [ $_ok = 0 ]; then
        _shttp_failures=$(( _shttp_failures+1 ))
        _shttp_failures_flow=$(( _shttp_failures_flow+1 ))
        _assertion_log "! [ $_condition ]: $_message"
    fi
    _shttp_assertions=$(( _shttp_assertions+1 ))
    _shttp_assertions_flow=$(( _shttp_assertions_flow+1 ))
}

#  Asserts that expected and actual
#+ are equal to one another.
#
#  -param $1 Fail message
#  -param $2 Expected value
#  -param $3 Actual value
areEquals() {
    local _message=${1:-''}
    local _expected=${2:-''}
    local _actual=${3:-''}
    if [ "$_expected" != "$_actual" ]; then
        _shttp_failures=$(( _shttp_failures+1 ))
        _shttp_failures_flow=$(( _shttp_failures_flow+1 ))
        _assertion_log "[ $_expected = $_actual ]: $_message"
    fi
    _shttp_assertions=$(( _shttp_assertions+1 ))
    _shttp_assertions_flow=$(( _shttp_assertions_flow+1 ))
}

#  Asserts that unexpected and actual
#+ are not equal to one another.
#
#  -param $1 Fail message
#  -param $2 Expected value
#  -param $3 Actual value
areNotEquals() {
    local _message=${1:-''}
    local _expected=${2:-''}
    local _actual=${3:-''}
    if [ "$_expected" = "$_actual" ]; then
        _shttp_failures=$(( _shttp_failures+1 ))
        _shttp_failures_flow=$(( _shttp_failures_flow+1 ))
        _assertion_log "[ $_expected != $_actual ]: $_message"
    fi
    _shttp_assertions=$(( _shttp_assertions+1 ))
    _shttp_assertions_flow=$(( _shttp_assertions_flow+1 ))
}


# ---------- Variables initialization

#  Request URL. During request,
#+ if its value is empty, the URL
#+ will be build by:
#+ '<protocol>://<domain><base-path><endpoint>'
_shttp_url=""

#  Request protocol:
#+ '<protocol>://any.host/any/endpoint'
_shttp_protocol=""

#  Request domain:
#+ 'https://<domain>/any/endpoint'
_shttp_domain=""

#  Request base path:
#+ 'https://any.host/<base-path>/endpoint'
_shttp_base_path=""

#  Request endpoint:
#+ 'https://any.host/any/<endpoint>'
_shttp_endpoint=""

#  Request method.
#  Allowed values:
#+   [GET, POST, PUT, PATCH,
#+   DELETE, HEAD, OPTIONS]
_shttp_method=""

#  Request headers. Default values
#+ for [Content-Type, Authorization, Host]
#+ could be assigned during request
#+ execution.
_shttp_headers=()

#  Request body in parts. During
#+ request execution these parts
#+ will be concatenated.
_shttp_body=()

#  Request key-value entries for
#+ data form. If it is specified
#+ default 'Content-Type' header
#+ will be 'multipart/form-data'
#+ otherwise will be 'application/json'.
_shttp_form=()

#  Request key-value entries for
#+ Query Parameters.
_shttp_query_params=()

#  Additional 'cURL' options.
_shttp_curl_opts=()

#  Authorization mode. Allowed values:
#+ [BASIC, HEADER, QPARAM, SKIP].
#    1. BASIC: HTTP Basic Authentication
#    2. HEADER: Header Authorization
#    3. QPARAM: Authorization via Query
#+      Parameters
#    4. SKIP: No authorization mode
_shttp_auth_mode=""

#  Authentication credential identifier.
#  The credential must be in 
#+ 'ws/credentials[.<env>].json'.
#  Regarding to '_shttp_auth_mode'
#+ credential must have the
#+ following fields:
#    1. BASIC: 'username', 'password'
#    2. HEADER: 'type', 'secret'
#    3. QPARAM: 'type', 'secret'
_shttp_auth_credential=""

#  Number of request executions.
_shttp_request_times=0

#  If value is defined, that command
#+ will be executed as last tasks
#+ of the request.
_shttp_editor_command=""

#  Response output base filename.
#  During request this filename
#+ will be used for make files:
#+ '<output>.output', '<output>.trace'
#+ and '<output>.asserts'.
_shttp_output=""

#  Configuration environment file.
#+ If environment is assigned
#+ file will have this form:
#+ 'ws/config.<env>.json'.
_shttp_env="ws/config.json"

#  Credentials environment file.
#+ If environment is assigned
#+ file will have this form:
#+ 'ws/credentials.<env>.json'.
_shttp_creds="ws/credentials.json"

#  Script input parameters.
_shttp_input_params="${*}"

#  Execution type, allowed values:
#    1. FLOW: End-to-end process
#    2. REQUEST: Single request
_shttp_execution_type=""

#  Current number of flow.
#  This field is updated by 
#+ '_execute_flow' for each
#+ iteration.
#  This value will be reset
#+ after complete all iterations.
_shttp_flow_index=0

#  Current number of execution.
#  This field is updated by 
#+ '_execute' for each iteration.
#  This value will be reset
#+ after complete all iterations.
_shttp_request_index=0

#  Assertions count.
_shttp_assertions_flow=0

#  Failed assertions count.
_shttp_failures_flow=0

#  Assertions count.
_shttp_assertions=0

#  Failed assertions count.
_shttp_failures=0

#  List of request options.
_shttp_request_opts=()

#  List of registered options.
declare -A _shttp_registered_opts


# ---------- Builder functions

#  Setter for '_shttp_url'.
#
#  -param $1 Request URL
url() {
    local _url=${1:-''}
    _shttp_url="$_url"
    info "Set [URL] with [$_shttp_url]"
}

#  Setter for '_shttp_protocol'.
#
#  -param $1 Request Protocol
protocol() {
    local _protocol=${1:-''}
    _shttp_protocol="$_protocol"
    info "Set [Protocol] with [$_shttp_protocol]"
}

#  Setter for '_shttp_domain'.
#
#  -param $1 Request domain
domain() {
    local _domain=${1:-''}
    _shttp_domain="$_domain"
    info "Set [Domain] with [$_shttp_domain]"
}

#  Setter for '_shttp_base_path'.
#
#  -param $1 Request base path
basePath() {
    local _path=${1:-''}
    _shttp_base_path="$_path"
    info "Set [Base-path] with [$_shttp_base_path]"
}

#  Setter for '_shttp_endpoint'.
#
#  -param $1 Request endpoint
endpoint() {
    local _endpoint=${1:-''}
    _shttp_endpoint="$_endpoint"
    info "Set [Endpoint] with [$_shttp_endpoint]"
}

#  Setter for '_shttp_method'.
#
#  -param $1 Request method
method() {
    local _method=${1:-''}
    case "$_method" in
        GET \
        | POST \
        | PUT \
        | PATCH \
        | DELETE \
        | HEAD \
        | OPTIONS)
            _shttp_method="$_method"
            info "Set [Method] with [$_shttp_method]"
        ;;
        *)
            fatal "Invalid [$_method] request method"
        ;;
    esac
}

#  Setter for '_shttp_headers'.
#
#  -param $@ Request headers
headers() {
    local _length=$#
    if (( _length > 0 )); then
        for _header in "$@"; do
            _shttp_headers+=( "$_header" )
            info "Set [Header] with [$_header]"
        done
    fi
}

#  Setter for '_shttp_body'.
#+ Additional functionality
#+ is to repeat the content
#+ part as times as repeat
#+ or size options are passed.
#+ For repeat the content is
#+ repeated '$2' times.
#+ For size the content is
#+ repeated until content
#+ has the required size.
#
#  -param $1 Offset value
#  -param $2 Repeat option:
#+           '[0-9]+t' for times
#+           '[0-9]+s' for size
#+             in bytes
#  -param $@ Request body parts
body() {
    local _offset=0
    local _repeat=0
    local _max_size=0
    if [ $# -gt 2 ]; then
        if [[ "$1" =~ ^[0-9]+$ ]]; then
            _offset=$1
            shift
            if [[ "$1" =~ ^[0-9]+t$ ]]; then
                _repeat=$( echo "$1" | cut -d t -f 1 )
                shift
            elif [[ "$1" =~ ^[0-9]+s$ ]]; then
                _max_size=$( echo "$1" | cut -d s -f 1 )
                shift
            fi
        fi
    fi
    local _length=${#_shttp_body[@]}
    local _current_total=0
    if (( _length > 0 )); then
        local _current_body="${_shttp_body[*]}"
        _current_total=${#_current_body}
    fi
    local _size=0
    if (( $# > 0 )); then
        if (( _repeat > 0 )); then
            _repeat=$(( _repeat-_offset ))
            for (( _i=1; _i<=_repeat; _i++ )); do
                for _part in "$@"; do
                    _shttp_body+=( "$_part" )
                    _size=$(( _size+${#_part}  ))
                done
            done
        elif (( _max_size > 0 )); then
            _max_size=$(( _max_size-_current_total-_offset ))
            for (( ; ; )); do
                for _part in "$@"; do
                    _shttp_body+=( "$_part" )
                    _size=$(( _size+${#_part}  ))
                done
                if (( _size >= _max_size )); then
                    break
                fi
            done
        else
            for _part in "$@"; do
                _shttp_body+=( "$_part" )
                _size=$(( _size+${#_part}  ))
            done
        fi
    fi
    _current_total=$(( _current_total+_size ))
    info "Appended [$_size] bytes to [Body], total [$_current_total]"
}

#  Setter for '_shttp_form'.
#
#  -param $@ Request form
form() {
    local _length=$#
    if (( _length > 0 )); then
        for _form in "$@"; do
            _shttp_form+=( "$_form" )
            info "Set [Form] with [$_form]"
        done
    fi
}

#  Setter for '_shttp_query_params'.
#
#  -param $@ Request query parameters
queryParams() {
    local _length=$#
    if (( _length > 0 )); then
        for _param in "$@"; do
            _shttp_query_params+=( "$_param" )
            info "Set [Query-Param] with [$_param]"
        done
    fi
}

#  Setter for '_shttp_curl_opts'.
#
#  -param $@ Additional cURL options
curlOpts() {
    local _length=$#
    if (( _length > 0 )); then
        for _opt in "$@"; do
            _shttp_curl_opts+=( "$_opt" )
            info "Set [cURL-opt] with [$_opt]"
        done
    fi
}

#  Setter for '_shttp_auth_mode'.
#
#  -param $1 Request authorization mode
authMode() {
    local _mode=${1:-''}
    _shttp_auth_mode="$_mode"
    info "Set [Authentication-mode] with [$_shttp_auth_mode]"
}

#  Setter for '_shttp_auth_credential'.
#
#  -param $1 Request authentication
#+           credential
credential() {
    local _credential=${1:-''}
    _shttp_auth_credential="$_credential"
    info "Set [Credential] with [$_shttp_auth_credential]"
}

#  Setter for '_shttp_request_times'.
#
#  -param $1 Request times
times() {
    local _times=${1:-''}
    _shttp_request_times="$_times"
    info "Set [Times] with [$_shttp_request_times]"
}

#  Setter for '_shttp_editor_command'.
#
#  -param $1 Editor command
editor() {
    local _editor=${1:-''}
    _shttp_editor_command="$_editor"
    info "Set [Editor] with [$_shttp_editor_command]"
}

#  Setter for '_shttp_output'.
#
#  -param $1 Response output
output() {
    local _output=${1:-''}
    _shttp_output="$_output"
    info "Set [Output] with [$_shttp_output]"
}

#  Setter for '_shttp_env'.
#
#  -param $1 Environment suffix
env() {
    local _env=${1:-''}
    if [ -n "$_env" ]; then
        _shttp_env="ws/config.$_env.json"
        _shttp_creds="ws/credentials.$_env.json"
    else
        _shttp_env="ws/config.json"
        _shttp_creds="ws/credentials.json"
    fi
    if ! [ -f "$_shttp_env" ]; then
        fatal "Configuration [$_shttp_env] does not exists"
    fi
    if ! [ -f "$_shttp_creds" ]; then
        fatal "Credentials [$_shttp_creds] does not exists"
    fi
    info "Set [Configuration] with [$_shttp_env]"
    info "Set [Credentials] with [$_shttp_creds]"
}


# ---------- Internal functions

#  Check if word exists is a
#+ key-words:
#    1. Start with 'before_'
#    2. Start with 'after_'
#
#  -param $1 Name of key-word
#  -return '1' if keyword exist
#+         otherwise '0'
_is_keyword() {
    local _name=${1:-''}
    local _found=0
    case "$_name" in
        before_* | after_*)
            _found=1
        ;;
    esac
    echo $_found
}

#  Check if function is already
#+ declared.
#
#  -param $1 Function name
#  -return '1' if exist function
#+         otherwise '0'
_has_func() {
    local _func=${1:-''}
    local _exists=1
    #  shellcheck disable=SC2034
    _exists=$( declare -f "$_func" > /dev/null ; echo $? )
    if (( _exists == 0 )); then
        echo 1
    else
        echo 0
    fi
}

#  Execute function if it is
#+ already decared.
#
#  -param $1 Function name
_execute_if_exist() {
    local _func=${1:-''}
    local _has_func=0
    _has_func=$( _has_func "$_func" )
    if (( _has_func == 1 )); then
        $_func
    fi
}

#  Execute flow lifecycle:
#    1. Execute 'before_api' function
#+      if it is declared.
#    2. Execute the flow.
#    3. Execute 'after_api' function
#+      if it is declared.
#    4. Show assertion results.
#  If times parameter is passed
#+ the execution will be performed
#+ for that number. 
#
#  -param $1 Request flow
#  -param $2 Request flow times
#+           (positive values)
_execute_flow() {
    local _command=${1:-''}
    local _times=${2:-1}
    if (( _times < 1 )); then
        _times=1
    fi
    for (( _i=1; _i<=_times; _i++ )); do
        _shttp_flow_index="$_i"
        _shttp_assertions_flow=0
        _shttp_failures_flow=0
        info "$_i: Init flow [$_command]"
        _execute_if_exist before_api
        $_command "$_shttp_flow_index"
        _execute_if_exist after_api
        _show_assertion_results "FLOW"
        info "$_i: Flow [$_command] completed"
    done
    _shttp_flow_index=0
}

#  Execute request lifecycle:
#    1. Initialize request variables.
#    2. Execute 'before_api' function
#+      if it is declared.
#    3. Execute the command.
#    4. Set request method based on
#+      command name if it was not
#+      assigned during the command
#+      execution.
#    5. Execute the request.
#    6. Execute 'after_api' function
#+      if it is declared.
#    7. Execute open editor task.
#    8. Show assertion results.
#  If times parameter is passed
#+ the execution will be performed
#+ for that number. 
#
#  -param $1 Request command
#  -param $2 Request execution times
#+           (positive values)
_execute() {
    local _command=${1:-''}
    local _times=${2:-1}
    if (( _times < 1 )); then
        _times=1
    fi
    for (( _i=1; _i<=_times; _i++ )); do
        _shttp_request_index="$_i"
        _shttp_assertions=0
        _shttp_failures=0
        info "$_i: Init request [$_command]"
        _init_vars
        if [ "$_shttp_execution_type" = "REQUEST" ]; then
            _execute_if_exist before_api
        fi
        $_command "$_shttp_request_index"
        _set_method "$_command"
        _request "$_command"
        if [ "$_shttp_execution_type" = "REQUEST" ]; then
            _execute_if_exist after_api
        fi
        _editor_command
        _show_assertion_results "REQUEST"
        info "$_i: Request [$_command] completed"
    done
    _shttp_request_index=0
}

#  Initilize request variables.
#  If the variable was set via
#+ options, the value will not
#+ change.
_init_vars() {
    _shttp_url=""
    _shttp_method=""
    _shttp_base_path=""
    _shttp_endpoint=""
    _shttp_headers=()
    _shttp_body=()
    _shttp_form=()
    _shttp_query_params=()
    _shttp_curl_opts=()
    _shttp_editor_command=""
    _shttp_output=""
    if [[ "$_shttp_input_params" != *"--local"* ]]; then
        _shttp_protocol=""
        _shttp_domain=""
    fi    
    if [[ "$_shttp_input_params" != *"--auth-"* ]]; then
        _shttp_auth_mode=""
        _shttp_auth_credential=""
    fi
}

#  Put default values to empty
#+ variables. The default
#+ not null values are taken
#+ from 'ws/config[.<env>].json'.
#    1. '_shttp_protocol': 'get protocol'
#    2. '_shttp_domain': 'get domain'
#    3. '_shttp_base_path': 'get basePath'
#    4. '_shttp_endpoint': 'get endpoint'
#    5. '_shttp_method': 'get method'
#    6. '_shttp_auth_mode': 'get authMode'
#    7. '_shttp_auth_credential': 'get authCredential'
#    8. '_shttp_editor_command': 'get editorCommand'
#    9. '_shttp_headers': (for each in)
#+      'get headers'
#    10. '_shttp_body': (for each in)
#+       'get body'
#    11. '_shttp_form': (for each in)
#+       'get form'
#    12. '_shttp_query_params': (for each in)
#+        'get queryParams'
#    13. '_shttp_curl_opts': (for each in)
#+       'get curlOpts'
_default_config() {
    local _name=""
    local _val=""
    local _vals=()
    local _length=0
    if [ -z "$_shttp_protocol" ]; then
        _val=$( get protocol )
        if [ "$_val" != "null" ]; then protocol "$_val" ; fi
    fi
    if [ -z "$_shttp_domain" ]; then
        _val=$( get domain )
        if [ "$_val" != "null" ]; then domain "$_val" ; fi
    fi
    if [ -z "$_shttp_base_path" ]; then
        _val=$( get basePath )
        if [ "$_val" != "null" ]; then basePath "$_val" ; fi
    fi
    if [ -z "$_shttp_endpoint" ]; then
        _val=$( get endpoint )
        if [ "$_val" != "null" ]; then endpoint "$_val" ; fi
    fi
    if [ -z "$_shttp_method" ]; then
        _val=$( get method )
        if [ "$_val" != "null" ]; then method "$_val" ; fi
    fi
    if [ -z "$_shttp_auth_mode" ]; then
        _val=$( get authMode )
        if [ "$_val" != "null" ]; then authMode "$_val" ; fi
    fi
    if [ -z "$_shttp_auth_credential" ]; then
        _val=$( get authCredential )
       if [ "$_val" != "null" ]; then credential "$_val" ; fi
    fi
    if [ -z "$_shttp_editor_command" ]; then
        _val=$( get editorCommand )
        if [ "$_val" != "null" ]; then editor "$_val" ; fi
    fi
    _length=${#_shttp_headers[@]}
    if (( _length == 0 )); then
        _length=$( jq  '.headers | length' "$_shttp_env" )
        if (( _length > 0)); then
            _vals=( $( jq ".headers | .[]" "$_shttp_env" ) )
            for _i in "${_vals[@]}"; do headers "$_i" ; done
        fi
    fi
    _length=${#_shttp_body[@]}
    if (( _length == 0 )); then
        _length=$( jq  '.body | length' "$_shttp_env" )
        if (( _length > 0)); then
            _vals=( $( jq ".body | .[]" "$_shttp_env" ) )
            for _i in "${_vals[@]}"; do body "$_i" ; done
        fi
    fi
    _length=${#_shttp_form[@]}
    if (( _length == 0 )); then
        _length=$( jq  '.form | length' "$_shttp_env" )
        if (( _length > 0)); then
            _vals=( $( jq ".form | .[]" "$_shttp_env" ) )
            for _i in "${_vals[@]}"; do form "$_i" ; done
        fi
    fi
    _length=${#_shttp_query_params[@]}
    if (( _length == 0 )); then
        _length=$( jq  '.queryParams | length' "$_shttp_env" )
        if (( _length > 0)); then
            _vals=( $( jq ".queryParams | .[]" "$_shttp_env" ) )
            for _i in "${_vals[@]}"; do queryParams "$_i" ; done
        fi
    fi
    _length=${#_shttp_curl_opts[@]}
    if (( _length == 0 )); then
        _length=$( jq  '.curlOpts | length' "$_shttp_env" )
        if (( _length > 0)); then
            _vals=( $( jq ".curlOpts | .[]" "$_shttp_env" ) )
            for _i in "${_vals[@]}"; do curlOpts "$_i" ; done
        fi
    fi
}

#  Put default values to empty
#+ variables.
#    1. '_shttp_protocol': 'https'
#    2. '_shttp_url':
#+      <protocol>://<domain><base-path><endpoint>
#    3. '_shttp_auth_mode': 'SKIP'
#    4. '_shttp_output': 
#+      'output/<main-script>.yyyy-mm-dd.hh_mm_ss'
_default_vars() {
    if [ -z "$_shttp_protocol" ]; then
        protocol "https"
    fi
    if [ -z "$_shttp_url" ]; then
        url "${_shttp_protocol}://${_shttp_domain}${_shttp_base_path}${_shttp_endpoint}"
    fi
    if [ -z "$_shttp_auth_mode" ]; then
        authMode "SKIP"
    fi
    if [ -z "$_shttp_output" ]; then
        output "output/$( basename "$0" ).$( date '+%Y-%m-%d.%H_%M_%S' )"
    fi
}

#  This lifecycle function is called
#+ for request execution:
#    1. Set default request variables
#+      using 'ws/config[.<env>].json'.
#    2. Set default request variables.
#    3. Append default 'Content-Type' to
#+      headers.
#    4. Append authentication to request.
#    5. Set body to a body file.
#    6. Build 'cURL' command.
#    7. Execute 'before_<command>' function
#+      if it is declared.
#    8. Execute 'cURL' command.
#    9. Execute 'after_<command>' function
#+      if it is declared.
#    10. Clean and append details into
#+       '_shttp_output.trace' file.
#
#  -param $1 Request command
_request() {
    local _command=${1:-''}

    _default_config
    _default_vars
    _append_content_type
    _append_auth

    local _body_file=""
    local _curl=""
    _body_file=$( _append_body_to_file )
    _curl=$( _build_curl "$_body_file" )

    _execute_if_exist "before_${_command}"
    eval "$_curl"
    _execute_if_exist "after_${_command}"

    _clean_trace "$_curl" "$_body_file"

    printf '\n' ; cat "$_shttp_output.trace"
    printf '\n>>>>> response\n' ; cat "$_shttp_output.output"
    printf '\n\n'

    info "Created $_shttp_output.trace"
    info "Created $_shttp_output.output"
}

#  This lifecycle function is called
#+ for request execution:
#    1. Look for request method at
#+      beginning of the command name.
#+      The search is case insensitive.
#+      A valid command must have the
#+      form '<verb><complement-name>',
#+      with one of these verbs: 'get',
#+      'post', 'put', 'patch', 'delete',
#+      'head' or 'options'.
#    2. If command is valid, '_shttp_method'
#+      will have the respective verb.
#
#  -param $1 Command name
_set_method() {
    if [ -z "$_shttp_method" ]; then
        local _command=${1:-''}
        shopt -s nocasematch
        case "$_command" in
            get*)
                method "GET"
            ;;
            post*)
                method "POST"
            ;;
            put*)
                method "PUT"
            ;;
            patch*)
                method "PATCH"
            ;;
            delete*)
                method "DELETE"
            ;;
            head*)
                method "HEAD"
            ;;
            options*)
                method "OPTIONS"
            ;;
        esac
        shopt -u nocasematch
    fi
}

#  Look for existing header by name,
#+ if header does not exist a new
#+ entry is added to '_shttp_headers'
#+ otherwise skip assignment.
#
#  -param $1 Header name
#  -param $2 Header value
_append_if_missing_header() {
    local _name=${1:-''}
    local _val=${2:-''}
    shopt -s nocasematch
    local _found=0
    local _length=${#_shttp_headers[@]}
    if (( _length > 0 )); then
        for _header in "${_shttp_headers[@]}"; do
            if [[ "$_header" == "$_name:"* ]]; then
                _found=1
                break
            fi
        done
    fi
    shopt -u nocasematch
    if [ $_found = 0 ]; then
        headers "$_name: $_val"
    fi
}

#  Set value to 'Content-Type' header.
#  If '_shttp_form' has at least one value
#+ 'Content-Type' will be
#+ 'multipart/form' otherwise will be
#+ 'application/json'.
_append_content_type() {
    local _length=${#_shttp_form[@]}
    if (( _length > 0 )); then
        local _val="multipart/form-data"
    else
        local _val="application/json"
    fi
    _append_if_missing_header "Content-Type" "$_val"
}

#  Setup the authorization mode based
#+ on '_shttp_auth_mode':
#    1. BASIC: Set basic authentication
#+      type by 'cURL' options.
#+      Use from credential: 'username',
#+      'password'.
#    2. HEADER: Set authentication
#+      token by request header.
#+      Use from credential: 'type',
#+      'secret'. If 'type' is not
#+      found, default value will be
#+      'token'.
#    3. QPARAM: Set to 'URL' a
#+      token as query parameter.
#+      Use from credential: 'type',
#+      'secret'. If 'type' is not
#+      found, default value will be
#+      'access_token'.
#    4. SKIP: Skip authorization setup.
#    5. Another value: Exit script using
#+      'fatal' logging function.
_append_auth() {
    local _username=""
    local _password=""
    local _secret=""
    local _type=""
    case "$_shttp_auth_mode" in
        BASIC)
            _username=$( _credential_part username )
            _password=$( _credential_part password )
            if [ "$_password" = "null" ]; then
                curlOpts "--basic" "-u $_username"
            else
                eval "_password=$_password"
                curlOpts "--basic" "-u $_username:$_password"
            fi
        ;;
        HEADER)
            _type=$( _credential_part type "token" )
            _secret=$( _credential_part secret )
            eval "_secret=$_secret"
            _append_if_missing_header "Authorization" "$_type $_secret"
        ;;
        QPARAM)
            _type=$( _credential_part type "access_token" )
            _secret=$( _credential_part secret )
            eval "_secret=$_secret"
            queryParams "$_type=$_secret"
        ;;
        SKIP)
            :
        ;;
        *)
            local _has_ext_auth=""
            _has_ext_auth=$( _has_func process_auth )
            if (( _has_ext_auth == 1 )); then
                process_auth
            else
                fatal "Invalid authorization mode [$_shttp_auth_mode]"
            fi
        ;;
    esac
}

#  Get the credential part for
#+ '_shttp_auth_credential'.
#
#  -param $1 Part name
#  -param $2 Default name
#  -return Credential part value
_credential_part() {
    local _name=${1:-''}
    local _default=${2:-'null'}
    local _part=""
    _part=$( < "$_shttp_creds" \
        jq ".[] | select(.id==\"$_shttp_auth_credential\") | .$_name")
    _part=$( echo "$_part" | sed -e 's/^"//' -e 's/"$//' )
    if [ "$_part" = "null" ]; then
        _part="$_default"
    fi
    echo "$_part"
}

#  Append every '_shttp_body' element
#+ into body content. A new line can
#+ be done using '\n' as unique
#+ characters in the line.
#  At least one variable must be
#+ appended for generate the body
#+ file.
#
#  -return Body temporal file if
#+         it was generated otherwise
#+         return empty
_append_body_to_file() {
    local _body_file=""
    local _length=${#_shttp_body[@]}
    local _appended=0
    _body_file="ws/body.$( date '+%s.%N' ).json.tmp"
    if (( _length > 0 )); then
        for _line in "${_shttp_body[@]}"; do
            if [ "$_line" = "\n" ]; then
                echo | tee -a "$_body_file" > /dev/null
            else
                echo "$_line" | tee -a "$_body_file" > /dev/null
            fi
        done
        _appended=$(( _appended+1 ))
    fi
    if (( _appended < 1 )); then
        _body_file=""
    fi
    echo "$_body_file"
}

#  Build 'cURL' command. This
#+ uses the following template:
#    'curl -X <_shttp_method> -s -v \
#+       -o "<_shttp_output>.output" \
#+       -H "<_shttp_headers[1..n]>" \
#+       -d "<_shttp_query_params[1..n]>" \
#+       -F "<_shttp_form[1..n]>" \
#+       --data-binary "@<:body_file>" \
#+       <_shttp_curl_opts[1..n]> \
#+       <_shttp_url> > "<_shttp_output>.trace" 2>&1'
#
#  -param $1 Body temporal file
#  -return cURL command as string
_build_curl() {
    local _body_file=${1:-''}
    local _curl=(
        "curl -X $_shttp_method -s -v \\"
        "-o \"$_shttp_output.output\" \\"
    )
    local _length=${#_shttp_headers[@]}
    if (( _length > 0 )); then
        for _header in "${_shttp_headers[@]}"; do
            _curl+=( "-H \"$_header\" \\" )
        done
    fi
    _length=${#_shttp_query_params[@]}
    if (( _length > 0 )); then
        for _param in "${_shttp_query_params[@]}"; do
            _curl+=( "-d \"$_param\" \\" )
        done
    fi
    _length=${#_shttp_form[@]}
    if (( _length > 0 )); then
        for _form in "${_shttp_form[@]}"; do
            _curl+=( "-F \"$_form\" \\" )
        done
    fi
    if [ -n "$_body_file" ]; then
        _curl+=( "--data-binary \"@$_body_file\" \\" )
    fi
    _length=${#_shttp_curl_opts[@]}
    if (( _length > 0 )); then
        for _opt in "${_shttp_curl_opts[@]}"; do
            _curl+=( "$_opt \\" )
        done
    fi
    _curl+=( "$_shttp_url > \"$_shttp_output.trace\" 2>&1" )
    echo "${_curl[*]}"
}

#  Get a request detail file
#+ based on verbose 'cURL' file.
#  The trace file contains:
#+ request headers, response
#+ headers, request body content,
#+ response body content,
#+ 'cURL' command used.
#
#  -param $1 cURL command
#  -param $2 Body temporal file
_clean_trace() {
    #  shellcheck disable=SC2178
    local _curl=${1:-''}
    local _body_file=${2:-''}

    sed -i -e '/^[*{} ]/d' "$_shttp_output.trace" # Remove unnecessary log lines
    sed -i -e "/^> $/a> {{body}}\n" "$_shttp_output.trace" # Append body tag 
    sed -i -e 's/^..//' "$_shttp_output.trace" # Remove first two characters in each line

    if [ -n "$_body_file" ]; then
        echo "" | tee -a "$_shttp_output.trace" > /dev/null
        echo ">>>>> body" | tee -a "$_shttp_output.trace" > /dev/null
        < "$_body_file" tee -a "$_shttp_output.trace" > /dev/null # Append body content
        rm -f "$_body_file"
    fi

    echo "" | tee -a "$_shttp_output.trace" > /dev/null
    echo ">>>>> curl" | tee -a "$_shttp_output.trace" > /dev/null
    #  shellcheck disable=SC2128
    echo "$_curl" | tee -a "$_shttp_output.trace" > /dev/null # Append CURL command
}

#  Log a message about assertion fail
#+ into '_shttp_output.asserts'.
#
#  -param $* Log message
_assertion_log() {
    echo "$( date '+%Y-%m-%d %T.%N' ) [ASSERTION]   $*" | tee -a "$_shttp_output.asserts" >&2
}

#  Show assertion results if
#+ assetion count is greater
#+ than '0'.
#
#  -param $1 Execution type
_show_assertion_results() {
    local _type=${1:-''}
    local _assertions=0
    local _failures=0
    case "$_shttp_execution_type" in
        REQUEST)
            _assertions=$_shttp_assertions
            _failures=$_shttp_failures
        ;;
        FLOW)
            _assertions=$_shttp_assertions_flow
            _failures=$_shttp_failures_flow
        ;;
    esac
    if [ "$_shttp_execution_type" = "$_type" ]; then
        if (( _assertions > 0 )); then
            info "Created $_shttp_output.asserts"
            if [ $_failures = 0 ]; then
                _assertion_log "$( basename "$0" ): [PASSED] - [$_assertions] of [$_assertions] assertions passed"
            else
                _assertion_log "$( basename "$0" ): [FAILED] - [$_failures] of [$_assertions] assertions failed"
            fi
        fi
    fi
}

#  Editor command is used
#+ after request processing.
#  The design was thinking
#+ about to open request
#+ results into file
#+ editor and then process
#+ it manually.
#  Execution takes two steps:
#    1. Variables resolution
#+      if any exist in the
#+      original definition.
#    2. Command execution.
_editor_command() {
    if [ -n "$_shttp_editor_command" ]; then
        eval "_shttp_editor_command=\"$_shttp_editor_command\""
        info "Start [$_shttp_editor_command]"
        eval "$_shttp_editor_command"
    fi
}

#  Cleanup all temp JSON files from
#+ workspace.
#  This function is called after
#+ execute the main code or after
#+ get an error.
_finally_http_api() {
    if [ -d ws ]; then
        rm -f ws/*.json.tmp
    fi
}


# ---------- Option functions

#  Look for parameters belong
#+ to option. Parameters are
#+ collected and they are sent
#+ to a 'callback' function.
#+ The 'callback' is collected
#+ from '_shttp_registered_opts'.
#  Search is interrupted
#+ if another option is found
#+ in the parameters.
#  Valid options have the form:
#+ '--<option>'.
#
#  -param $1 Looked option
#  -param $* Input parameters
_look_for_params() {
    local _option=${1:-''}
    local _params=()
    local _found=0
    local _length=0
    local _callback=""
    shift
    for _param in "$@"; do
        if [ $_found = 1 ]; then
            if [[ "$_param" == "--"* ]]; then
                _length=${#_params[@]}
                _callback=${_shttp_registered_opts[$_option]}
                if (( _length > 0 )); then
                    $_callback "${_params[@]}"
                else
                    $_callback
                fi
                _found=2 # Option executed flag
                _params=()
            else
                _params+=( "$_param" )
            fi
        fi
        if [ "$_param" = "$_option" ]; then
            _found=1 # Option found flag
        fi
    done
    if [ $_found = 1 ]; then
        _length=${#_params[@]}
        _callback=${_shttp_registered_opts[$_option]}
        if (( _length > 0 )); then
            $_callback "${_params[@]}"
        else
            $_callback
        fi
    fi
    if (( _found > 0 )); then
        return 0
    else
        return 1
    fi
}

#  Register an option to
#+ '_shttp_request_opts' and
#+ '_shttp_registered_opts'.
#
#  -param $1 Option
#  -param $2 Callback function
#  -param $3 Is request option:
#+           '1' for 'true'
#+           '0' for 'false'
_register_opt() {
    local _option=${1:-''}
    local _callback=${2:-''}
    local _is_req_opt=${3:-0}
    _shttp_registered_opts[$_option]="$_callback"
    if [ "$_is_req_opt" = "1" ]; then
        _shttp_request_opts+=( "$_option" )
    fi
}

#  List the names of main script
#+ functions. Names contained
#+ in the 'keywords' are discarded.
#
#  -return Command list
_list_commands() {
    declare -a _functions=(
        $( declare -F )
    )
    local _length=${#_functions[@]}
    if (( _length > 0 )); then
        for _function in "${_functions[@]}"; do
            local _name=""
            local _belong=""
            local _is_key=0
            _name=$( echo "$_function" | cut -d ' ' -f 3 )
            _belong=$( grep "${_name}\s*()" "$0" )
            _is_key=$( _is_keyword "$_name" )
            if [ -n "$_belong" ] \
                   && [[ "$_name" != "_"* ]] \
                   && (( _is_key == 0 )); then
                echo "$_name"
            fi
        done
    fi
}
_register_opt --list _list_commands 0
expr "$*" : ".*--list" > /dev/null \
    && _look_for_params --list "$@" \
    && exit 0

#  Copy the configuration and credentials
#+ files. The 'from' files must exist. If
#+ 'to' files already exist those will be
#+ replaced with new ones.
#
#  --param $1 From environment
#  --param $2 From environment
_copy_env() {
    local _from=${1:-''}
    local _to=${2:-''}
    if [ -z "$_to" ]; then
        fatal "Required [$2:env-to] parameter"
    fi
    if [ "$_from" = "$_to" ]; then
        fatal "Parameters are the same [$_from = $_to]"
    fi
    if [ "$_from" = "default" ]; then
        _from=""
    else
        _from=".$_from"
    fi
    if [ "$_to" = "default" ]; then
        _to=""
    else
        _to=".$_to"
    fi
    if ! [ -f "ws/config$_from.json" ]; then
        fatal "File [ws/config$_from.json] does not exist"
    fi
    if ! [ -f "ws/credentials$_from.json" ]; then
        fatal "File [ws/credentials$_from.json] does not exist"
    fi
    if [ -f "ws/config$_to.json" ]; then
        rm -f "ws/config$_to.json"
        info "Deleted [ws/config$_to.json] file"
    fi
    if [ -f "ws/credentials$_to.json" ]; then
        rm -f "ws/credentials$_to.json"
        info "Deleted [ws/credentials$_to.json] file"
    fi
    cp "ws/config$_from.json" "ws/config$_to.json"
    cp "ws/credentials$_from.json" "ws/credentials$_to.json"
    info "Added [ws/config$_to.json] file"
    info "Added [ws/credentials$_to.json] file"
}
_register_opt --copy _copy_env 0
expr "$*" : ".*--copy" > /dev/null \
    && _look_for_params --copy "$@" \
    && exit 0

#  Save key-value to 'ws/config[.<env>].json'
#+ using 'put' function.
#
#  -param $1 Name of the entry
#  -param $2 Value of the entry
_add_config() {
    local _name=${1:-''}
    local _val=${2:-''}
    put "$_name" "$_val"
}
_register_opt --add _add_config 0
expr "$*" : ".*--add" > /dev/null \
    && _look_for_params --add "$@" \
    && exit 0

#  Get key-value from 'ws/config[.<env>].json'
#+ using 'get' function.
#
#  -param $1 Name of the entry
#  -return Value of the entry
_get_config() {
    local _name=${1:-''}
    local _val=""
    if [ -n "$_name" ]; then
        _val=$( get "$_name" )
    fi
    echo "$_val"
}
_register_opt --get _get_config 0
expr "$*" : ".*--get" > /dev/null \
    && _look_for_params --get "$@" \
    && exit 0

#  Remove key-value to 'ws/config[.<env>].json'
#+ using 'remove' function.
#
#  -param $1 Name of the entry
_remove_config() {
    local _name=${1:-''}
    remove "$_name"
}
_register_opt --remove _remove_config 0
expr "$*" : ".*--remove" > /dev/null \
    && _look_for_params --remove "$@" \
    && exit 0

#  List the keys of 'ws/config[.<env>].json'.
#
#  -return 'ws/config[.<env>].json' keys
_get_config_keys() {
    local _keys=(
        $( jq "keys | .[]" "$_shttp_env" )
    )
    local _length=${#_keys[@]}
    if (( _length > 0 )); then
        for _key in "${_keys[@]}"; do
            echo "$_key" | sed -e 's/^"//' -e 's/"$//'
        done
    fi
}
_register_opt --keys _get_config_keys 0
expr "$*" : ".*--keys" > /dev/null \
    && _look_for_params --keys "$@" \
    && exit 0

#  Clean all files from 'output'
#+ directory.
_clean_output_files() {
    if [ -d output ]; then
        declare -a _selected=(
            $( find "output" -name "*" -type f )
        )
         local _length=${#_selected[@]}
        if (( _length > 0 )); then
            for _file in "${_selected[@]}"; do
                info "Removed [$_file] output"
            done
            rm -rf output/*
            info "Cleaning completed"
        else
            info "Output directory is empty"
        fi
    fi
}
_register_opt --clean _clean_output_files 0
expr "$*" : ".*--clean" > /dev/null \
    && _look_for_params --clean "$@" \
    && exit 0

#  Set the configuration environment
#+ suffix. This value will be used
#+ for get current configuration
#+ append it to 'ws/config-<env>.json'.
#
#  -param $1 Environment suffix
_set_env() {
    local _env=${1:-''}
    env "$_env"
}
_register_opt --env _set_env 1
expr "$*" : ".*--env" > /dev/null \
    && _look_for_params --env "$@"

#  Add a new variable, into script,
#+ which will be taken as priority
#+ config for 'get' function.
#
#  -param $1 Name of the entry
#  -param $2 Value of the entry
_set_config() {
    local _name=${1:-''}
    local _val=${2:-''}
    update "ws/override.json.tmp" ". + { \"$_name\": $_val }"
    info "Set temporal [$_name] with value [$_val]"
}
_register_opt --set _set_config 1
expr "$*" : ".*--set" > /dev/null \
    && _look_for_params --set "$@"
    
#  Set '_shttp_domain' to 'localhost'. Default
#+ port is 8080 but it can be specified
#+ as first parameter and will override
#+ default port.
#  Protocol is changed as well and takes
#+ 'http' as value.
#
#  -param $1 Port value
_set_localhost() {
    local _port=${1:-''}
    if [ -z "$_port" ]; then
        _port="8080"
    fi
    protocol "http"
    domain "localhost:$_port"
}
_register_opt --local _set_localhost 1
expr "$*" : ".*--local" > /dev/null \
    && _look_for_params --local "$@"

#  Set credential to '_shttp_auth_credential'.
_set_credentials() {
    local _credential=${1:-''}
    credential "$_credential"
}
_register_opt --auth-basic _set_credentials 1
expr "$*" : ".*--auth-basic" > /dev/null \
    && _look_for_params --auth-basic "$@" \
    && authMode "BASIC"
_register_opt --auth-header _set_credentials 1
expr "$*" : ".*--auth-header" > /dev/null \
    && _look_for_params --auth-header "$@" \
    && authMode "HEADER"
_register_opt --auth-qparam _set_credentials 1
expr "$*" : ".*--auth-qparam" > /dev/null \
    && _look_for_params --auth-qparam "$@" \
    && authMode "QPARAM"
_register_opt --auth-skip _set_credentials 1
expr "$*" : ".*--auth-skip" > /dev/null \
    && _look_for_params --auth-skip "$@" \
    && authMode "SKIP"

#  Set request execution times
#+ to '_shttp_request_times'.
_set_times() {
    local _times=${1:-''}
    times "$_times"
}
_register_opt --times _set_times 1
expr "$*" : ".*--times" > /dev/null \
    && _look_for_params --times "$@"

#  Get saved editor command from
#+ 'ws/config[.<env>].json and the value
#+ is assigned to '_shttp_editor_command'.
_open_editor() {
    editor "$( get editorCommand )"
}
_register_opt --open _open_editor 1
expr "$*" : ".*--open" > /dev/null \
    && _look_for_params --open "$@"


# ---------- Add-ons

#  Add-on files.
#  Filename must have
#+ the form: '<name>_ext'
declare -a _shttp_add_ons=(
    $( find . -name "*_ext" -type f )
)

#  Add-on files length.
readonly _shttp_add_ons_length=${#_shttp_add_ons[@]}

#  If exists add-on files
#+ they will be sourced.
if (( _shttp_add_ons_length > 0 )); then
    for _add_on in "${_shttp_add_ons[@]}"; do
        eval ". $_add_on"
        info "Add-on [$_add_on] sourced"
    done
else
    info "No add-ons sourced"
fi


# ---------- Main

#  Skip main code flag
readonly _shttp_skip=${SKIP_HTTP_API:-''}

#  Main code:
#    1. Get the 'command' input.
#    2. Set the exist 'main' function flag.
#    3. Discard 'command' if has 'option'
#+      format.
#    4. If 'command' or 'main' is present,
#+      execute request lifecycle: '_execute'.
#    5. Finally function is executed.
if [ "$_shttp_skip" != "true" ]; then
    trap _finally_http_api EXIT

    _shttp_command=${1:-''}
    _has_shttp_main=$( _has_func main )

    if [[ "$_shttp_command" == "--"* ]]; then
        _shttp_command=""
    fi

    if [ -z "$_shttp_command" ]; then
        info "No command to execute"
    elif [[ "$_shttp_command" == "flow"* ]]; then
        _shttp_execution_type="FLOW"
        _execute_flow "$_shttp_command" "$_shttp_request_times"
    elif (( _has_shttp_main == 1 )); then
        _shttp_execution_type="REQUEST"
        _execute main "$_shttp_request_times"
    else
        _shttp_execution_type="REQUEST"
        _execute "$_shttp_command" "$_shttp_request_times"
    fi
fi
