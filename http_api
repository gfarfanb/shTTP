#! /usr/bin/env bash
#  Simple HTTP API development environment.
#  -author Giovanni Farf√°n B.
set -euo pipefail
IFS=$'\n\t'

#  Show the help content.
_help_http_api() {
    local _content=(
        ""
        " Usage: ./<file>.sh <command> [--set <key-name> <value>] [--get <key-name>] [--add <key-name> <value>]"
        "                              [--remove <key-name>] [--get-keys] [--list] [--clean] [--host <host>]"
        "                              [--local <port>] [--auth-header] [--auth-qparam] [--open] [--help]"
        ""
        " Options:"
        "   --set <key-name> <value>:  Set a temporal key-value config. This won't saved to 'ws/config.json'"
        "   --get <key-name>:          Display the value for key from 'ws/config.json'"
        "   --add <key-name> <value>:  Add new key-value to 'ws/config.json'"
        "   --remove <key-name>:       Remove the key-value from 'ws/config.json'"
        "   --get-keys:                Display all keys from 'ws/config.json' file"
        "   --list:                    Display the <command> list (all functions defined into main script)"
        "   --clean:                   Clean up all output files 'output/*'"
        "   --host <host>:             Set host value to 'host' in 'ws/config.json'"
        "   --local <port>:            Set 'PROTOCOL' and 'DOMAIN' variables to local execution."
        "                                PROTOCOL: http"
        "                                DOMAIN:   localhost:<port> (default 8080)"
        "   --auth-header:             Set 'HEADER' to 'AUTH_MODE' for headers authorization."
        "   --auth-qparam:             Set 'QPARAM' to 'AUTH_MODE' for query params authorization."
        "   --open:                    Set 'EDITOR_COMMAND' with value defined on 'editorCommand' from 'ws/config.json'"
        "   --help:                    Display this help message"
    )
    echo "${_content[*]}"
}
expr "$*" : ".*--help" > /dev/null \
    && _help_http_api \
    && exit 0


#  Script filename.
readonly _basename=$( basename "$0" )


# ---------- Logging functions

#  Log filename.
readonly _log_file="/tmp/shTTP_${_basename%.*}.$( date '+%Y-%m-%d' ).log"

#  Log a message object with the INFO level.
#
#  -param $* Log message
info() { echo "$( date '+%Y-%m-%d %T.%N' ) [INFO]    $*" | tee -a "$_log_file" >&2 ; }

#  Log a message object with the WARNING level.
#
#  -param $* Log message
warning() { echo "$( date '+%Y-%m-%d %T.%N' ) [WARNING] $*" | tee -a "$_log_file" >&2 ; }

#  Log a message object with the ERROR level.
#
#  -param $* Log message
error() { echo "$( date '+%Y-%m-%d %T.%N' ) [ERROR]   $*" | tee -a "$_log_file" >&2 ; }

#  Log a message object with the FATAL level, 
#+ exit execution with 1.
#
#  -param $* Log message
fatal() { echo "$( date '+%Y-%m-%d %T.%N' ) [FATAL]   $*" | tee -a "$_log_file" >&2 ; exit 1 ; }


# ---------- Initialization

# 'cURL' is required
readonly _curl_version=$( curl --version )
if [ -z "$_curl_version" ]; then
    fatal "'curl' is not installed yet"
fi
#  'jq' (command-line JSON processor) is required
#+ https://github.com/stedolan/jq
readonly _jq_version=$( jq --version )
if [ -z "$_jq_version" ]; then
    fatal "'jq' is not installed yet"
fi
#  Output directory for trace and results files
if ! [ -d output ]; then 
    mkdir output || fatal "Imposible to create 'output' dorectory"
fi
#  Workspace directory for data execution
if ! [ -d ws ]; then 
    mkdir ws || fatal "Imposible to create 'ws' dorectory"
fi
#  Config JSON file
if ! [ -f "ws/config.json" ]; then
    echo '{ "host": null, "hosts": [] }' > "ws/config.json"
fi


# ---------- Util functions

#  Reverse the string input.
#
#  -param $1 String input
_rev() {
    local _input=${1:-''}
    local _rev=""
    for (( i=${#_input}-1; i>=0; i-- )); do 
        _rev="$_rev${_input:$i:1}"
    done
    echo "$_rev"
}


# ---------- Public functions

#  Update a JSON file using 'jq'.
#
#  -param $1 JSON file
#  -param $2 Change by 'jq'
update() {
    local _json=${1:-''}
    local _jq=${2:-''}
    local _temp=""
    _temp="ws/config.$( date '+%s.%N' ).json.tmp"
    jq "$_jq" "$_json" > "$_temp"
    mv "$_temp" "$_json"
}

#  Save key-value config to 'ws/config.json'.
#  This function has three different forms:
#    1. Only 'jq' query: put '.jq'
#    2. Name and 'jq' query: put 'name' '.jq'
#    3. Name and value: put 'name' 'value'
#  If 'jq' query is found, the function will
#+ use JSON result to take the value.
#
#  -param $1 Name of the entry or 'jq' for value
#  -param $2 Value of the entry or 'jq' for value
put() {
    local _name=${1:-''}
    local _val=${2:-''}
    local _jq=""
    if [ -z "$_val" ]; then
        _jq="$_name"
        _name=${_name//[0-9^\[\]]/}
        _name=$( _rev "$_name" )
        _name=$( echo "$_name" | cut -d '.' -f 1 )
        _name=$( _rev "$_name" )
    elif [[ "$_val" = \.* ]]; then
        _jq="$_val"
    fi
    if [ -n "$_jq" ]; then
        _val=$( < "$OUTPUT.output" jq "try $_jq catch null" )
    fi
    update "ws/config.json" ". + { \"$_name\": $_val }"
    info "Saved [$_name] with value [$_val] to workspace config"
}

#  Get key-value config in the following
#+ order: script variables and then from
#+ 'ws/config.json'.
#
#  -param $1 Name of the entry or 'jq'
#+           query (without '.' at the
#+           beginning of the query)
get() {
    local _name=${1:-''}
    local _val=""
    if [[ "$_name" =~ ^[a-zA-Z]*$ ]]; then
        _val=$( eval "echo \${$_name:-''}" )
    fi
    if [ -z "$_val" ]; then
        _val=$( jq ".$_name | tostring" "ws/config.json" )
        _val=$( echo "$_val" | sed -e 's/^"//' -e 's/"$//' )
    fi
    echo "$_val"
}

#  Remove key-value from 'ws/config.json'.
#  This function has two different forms:
#    1. 'jq' query: remove '.jq'
#    2. Field name: remove 'name'
#
#  -param $1 Name of the entry
remove() {
    local _name=${1:-''}
    if [[ "$_name" = \.* ]]; then
        local _val=""
        _val=$( jq "try $_name catch null" "ws/config.json" )
        if [ "$_val" != "null" ]; then
            update "ws/config.json" "del($_name)"
            info "Removed [$_name] from workspace config"
        fi
    else
        local _found=""
        _found=$( jq "has(\"$_name\")" "ws/config.json" )
        if [ "$_found" = "true" ]; then
            update "ws/config.json" "del(.$_name)"
            info "Removed [$_name] from workspace config"
        fi
    fi
}


# ---------- Variables initialization

#  Request protocol:
#+ '<protocol>://any.host/any/endpoint'
PROTOCOL="https"

#  Request protocol:
#+ 'https://<domain>/any/endpoint'
DOMAIN=$( get host )

#  Request method. Allowed values:
#+ [GET, POST, PUT, PATCH, DELETE,
#+ HEAD, OPTIONS]
METHOD=""

#  Request endpoint:
#+ 'https://any.host/<endpoint>'
ENDPOINT=""

#  Request headers. Default values
#+ for [Content-Type, Authorization, Host]
#+ could be assigned during request
#+ execution.
HEADERS=()

#  Request body.
BODY=""

#  Request body in parts. During
#+ request execution these parts
#+ will be concatenated.
BODY_PARTS=()

#  Requst key-value entries for
#+ data form. If it is specified
#+ default 'Content-Type' header
#+ will be 'multipart/form-data'
#+ otherwise will be 'application/json'.
FORM=()

#  Before request tasks. For each element 'eval'
#+ will be executed (as callback).
BEFORE_REQUEST=()

#  After request tasks. For each element 'eval'
#+ will be executed (as callback).
AFTER_REQUEST=()

#  Authentication mode. Allowed values:
#+ [HEADER, QPARAM, SKIP]
AUTH_MODE="SKIP"

#  If value is defined, that command
#+ will be executed as last tasks
#+ of the request.
EDITOR_COMMAND=""


# ---------- Internal functions

#  Key-words used internally like
#+ function names or field names.
#  The functions could be defined
#+ in the main API script if
#+ they are required during request
#+ lifecycle.
readonly _keywords=(
    'before_api' # Lifecycle function
    'after_api'  # Lifecycle function
)

#  Check if word passed as parameter
#+ exists in the key-words list.
#
#  -param $1 Name of key-word
#  -return '1' if keyword exist
#+         otherwise '0'
_is_keyword() {
    local _name=${1:-''}
    local _found=0
    for _key in "${_keywords[@]}"; do
        if [ "$_key" = "$_name" ]; then
            _found=1
            break
        fi
    done
    echo "$_found"
}

#  This lifecycle function is called
#+ before request execution:
#    1. Check if 'before_api' function
#+      exists in the main script and
#+      execute it.
#    2. Execute each task defined in
#+      'BEFORE_REQUEST' variable.
_before_request() {
    local _has_before=1
    #  shellcheck disable=SC2034
    _has_before=$( declare -f 'before_api' > /dev/null ; echo $? )
    if (( _has_before == 0 )); then
        before_api
    fi
    local _length=${#BEFORE_REQUEST[@]}
    if (( _length > 0 )); then
        for _callback in "${BEFORE_REQUEST[@]}"; do
            eval "$_callback"
        done
    fi
}

#  This lifecycle function is called
#+ after request execution:
#    1. Execute each task defined in
#+      'AFTER_REQUEST' variable.
#    2. Check if 'after_api' function
#+      exists in the main script and
#+      execute it.
_after_request() {
    local _length=${#AFTER_REQUEST[@]}
    if (( _length > 0 )); then
        for _callback in "${AFTER_REQUEST[@]}"; do
            eval "$_callback"
        done
    fi
    local _has_after=1
    #  shellcheck disable=SC2034
    _has_after=$( declare -f 'after_api' > /dev/null ; echo $? )
    if (( _has_after == 0 )); then
        after_api
    fi
}

#  This lifecycle function is called
#+ for request execution:
#    1. Set the 'URL' value (no protocol).
#    2. Set the 'OUTPUT' basename with
#+      format: 'output/<main-script>.
#+      yyyy-mm-dd.hh_mm_ss'.
#    3. Append default 'Content-Type' to
#+      headers.
#    4. Append authentication to request.
#    5. Set body to a body file.
#    6. Build 'cURL' command.
#    7. Execute 'cURL' command.
#    8. Clean and append details into
#+      'OUTPUT.trace' file.
_request() {
    eval "URL=\"$URL\""

    OUTPUT="output/$( basename "$0" ).$( date '+%Y-%m-%d.%H_%M_%S' )"

    info "Set METHOD with [$METHOD]"
    info "Set ENDPOINT [$ENDPOINT] to URL"
    info "Set URL with [$URL]"
    info "Set OUTPUT with [$OUTPUT]"

    _append_content_type
    _append_auth

    local _body_file=""
    local _curl=""
    _body_file=$( _append_body_to_file )
    _curl=$( _build_curl "$_body_file" )
    eval "$_curl"

    _clean_trace "$_curl" "$_body_file"

    printf '\n' ; cat "$OUTPUT.trace"
    printf '\n>>>>> response\n' ; cat "$OUTPUT.output"
    printf '\n\n'

    info "Created $OUTPUT.trace"
    info "Created $OUTPUT.output"
}

#  This lifecycle function is called
#+ for request execution:
#    1. Look for request method at
#+      beginning of the command name.
#+      The search is case insensitive.
#+      A valid command must have the
#+      form '<verb><complement-name>',
#+      with one of these verbs: 'get',
#+      'post', 'put', 'patch', 'delete',
#+      'head' or 'options'.
#    2. If command is valid, 'METHOD'
#+      will have the respective verb.
#
#  -param $1 Command name
_set_method() {
    if [ -z "$METHOD" ]; then
        local _command=${1:-''}
        shopt -s nocasematch
        case "$_command" in
            get*)
                METHOD="GET"
            ;;
            post*)
                METHOD="POST"
            ;;
            put*)
                METHOD="PUT"
            ;;
            patch*)
                METHOD="PATCH"
            ;;
            delete*)
                METHOD="DELETE"
            ;;
            head*)
                METHOD="HEAD"
            ;;
            options*)
                METHOD="OPTIONS"
            ;;
        esac
        shopt -u nocasematch
    fi
}

#  Look for existing header by name,
#+ if header does not exist a new
#+ entry is added to 'HEADERS'
#+ otherwise skip assignment.
#
#  -param $1 Header name
#  -param $2 Header value
_append_if_missing_header() {
    local _name=${1:-''}
    local _val=${2:-''}
    shopt -s nocasematch
    local _found=0
    local _length=${#HEADERS[@]}
    if (( _length > 0 )); then
        for _header in "${HEADERS[@]}"; do
            if [[ "$_header" == "$_name:"* ]]; then
                _found=1
                break
            fi
        done
    fi
    shopt -u nocasematch
    if [ $_found = 0 ]; then
        HEADERS+=( "$_name: $_val" )
    fi
}

#  Set value to 'Content-Type' header.
#  If 'FORM' has at least one value
#+ 'Content-Type' will be
#+ 'multipart/form' otherwise will be
#+ 'application/json'.
_append_content_type() {
    local _length=${#FORM[@]}
    if (( _length > 0 )); then
        local _val="multipart/form-data"
    else
        local _val="application/json"
    fi
    _append_if_missing_header "Content-Type" "$_val"
}

#  Setup the authorization mode based
#+ on 'AUTH_MODE':
#    1. HEADER: Set 'Authorization'
#+      header to bearer token type,
#+      token is obtained from
#+      'ws/config.json' using
#+      'apiToken' field.
#+      Set 'Host' header, value is
#+      obtained from 'ws/config.json'
#+      using 'host' field.
#    2. QPARAM: Set to 'URL' a
#+      token as query parameter
#+      with name 'token'. The value
#+      is obtained from 'ws/config.json'
#+      using 'apiToken' field.
#+      Set 'Host' header, value is
#+      obtained from 'ws/config.json'
#+      using 'host' field.
#    3. SKIP: Skip authorization setup.
#    4. Another value: Exit script using
#+      'fatal' logging function.
_append_auth() {
    case "$AUTH_MODE" in
        "HEADER")
            _append_if_missing_header "Authorization" "Bearer $( get apiToken )"
            _append_if_missing_header "Host" "$( get host )"
        ;;
        "QPARAM")
            if [[ "$URL" = *\?* ]]; then
                URL="$URL&token=$( get apiToken )"
            else
                URL="$URL?token=$( get apiToken )"
            fi
            _append_if_missing_header "Host" "$( get host )"
        ;;
        "SKIP")
            :
        ;;
        *)
        fatal "Invalid authorization mode [$AUTH_MODE]"
        ;;
    esac
    info "Set AUTH_MODE with [$AUTH_MODE]"
}

#  First, append every 'BODY_PARTS'
#+ into body content. Using 'BODY_PARTS'
#+ a new line can be done using '\n'
#+ as unique characters in the line.
#  Second, append 'BODY' into body
#+ content.
#  At least one variable must be
#+ appended for generate the body
#+ file.
#
#  -return Body temporal file if
#+         it was generated otherwise
#+         return empty
_append_body_to_file() {
    local _body_file=""
    local _length=${#BODY_PARTS[@]}
    local _appended=0
    _body_file="ws/body.$( date '+%s.%N' ).json.tmp"
    if (( _length > 0 )); then
        for _line in "${BODY_PARTS[@]}"; do
            if [ "$_line" = "\n" ]; then
                echo | tee -a "$_body_file" > /dev/null
            else
                echo "$_line" | tee -a "$_body_file" > /dev/null
            fi
        done
        _appended=$(( _appended+1 ))
    fi
    if [ -n "$BODY" ]; then
        echo "$BODY" | tee -a "$_body_file" > /dev/null
        _appended=$(( _appended+1 ))
    fi
    if (( _appended < 1 )); then
        _body_file=""
    fi
    echo "$_body_file"
}

#  Build 'cURL' command. Use
#+ the following variables
#+ during build:
#    1. METHOD: '-X <request-method>'
#    2. OUTPUT: '-o "$OUTPUT.output"',
#+      '> "$OUTPUT.trace" 2>&1'
#    3. HEADERS: '-H "<header>"'
#    4. FORM: '-F "<key>=<value>"'
#    5. Body file: '--data-binary "@<body-file>"'
#    6. PROTOCOL and URL: '<protocol>://<url>' 
#
#  -param $1 Body temporal file
#  -return cURL command as string
_build_curl() {
    local _body_file=${1:-''}
    local _curl=(
        "curl -X $METHOD -s -v -o \"$OUTPUT.output\" \\"
    )
    local _length=${#HEADERS[@]}
    if (( _length > 0 )); then
        for _header in "${HEADERS[@]}"; do
            _curl+=( "-H \"$_header\" \\" )
        done
    fi
    _length=${#FORM[@]}
    if (( _length > 0 )); then
        for _form in "${FORM[@]}"; do
            _curl+=( "-F \"$_form\" \\" )
        done
    fi
    if [ -n "$_body_file" ]; then
        _curl+=( "--data-binary \"@$_body_file\" \\" )
    fi
    _curl+=( "$PROTOCOL://$URL > \"$OUTPUT.trace\" 2>&1" )
    echo "${_curl[*]}"
}

#  Get a request detail file
#+ based on verbose 'cURL' file.
#  The trace file contains:
#+ request headers, response
#+ headers, request body content,
#+ response body content,
#+ 'cURL' command used.
#
#  -param $1 cURL command
#  -param $2 Body temporal file
_clean_trace() {
    #  shellcheck disable=SC2178
    local _curl=${1:-''}
    local _body_file=${2:-''}

    sed -i -e '/^[*{} ]/d' "$OUTPUT.trace" # Remove unnecessary log lines
    sed -i -e "/^> $/a> {{body}}\n" "$OUTPUT.trace" # Append body tag 
    sed -i -e 's/^..//' "$OUTPUT.trace" # Remove first two characters in each line

    if [ -n "$_body_file" ]; then
        echo "" | tee -a "$OUTPUT.trace" > /dev/null
        echo ">>>>> body" | tee -a "$OUTPUT.trace" > /dev/null
        < "$_body_file" tee -a "$OUTPUT.trace" > /dev/null # Append body content
        rm -rf "$_body_file"
    fi

    echo "" | tee -a "$OUTPUT.trace" > /dev/null
    echo ">>>>> curl" | tee -a "$OUTPUT.trace" > /dev/null
    #  shellcheck disable=SC2128
    echo "$_curl" | tee -a "$OUTPUT.trace" > /dev/null # Append CURL command
}

#  Editor command is used
#+ after request processing.
#  The design was thinking
#+ about to open request
#+ results into file
#+ editor and then process
#+ it manually.
#  Execution takes two steps:
#    1. Variables resolution
#+      if any exist in the
#+      original definition.
#    2. Command execution.
_editor_command() {
    if [ -n "$EDITOR_COMMAND" ]; then
        eval "EDITOR_COMMAND=\"$EDITOR_COMMAND\""
        info "Set EDITOR_COMMAND with [$EDITOR_COMMAND]"
        eval "$EDITOR_COMMAND"
    fi
}

#  Cleanup all temp JSON files from
#+ workspace.
#  This function is called after
#+ execute the main code or after
#+ get an error.
_finally_http_api() {
    if [ -d ws ]; then
        rm -rf ws/*.json.tmp
    fi
}


# ---------- Option functions

#  Look for parameters belong
#+ to option. Parameters are
#+ collected and they are sent
#+ to 'callback' function.
#  Search is interrupted
#+ if another option is found
#+ in the parameters.
#  Valid options have the form:
#+ '--<option>'.
#
#  -param $1 Callback function
#  -param $2 Looked option
#  -param $* Input parameters
_look_for_params() {
    local _callback=${1:-''}
    local _option=${2:-''}
    local _params=()
    local _found=0
    shift 2
    for _param in "$@"; do
        if [ $_found = 1 ]; then
            if [[ "$_param" == "--"* ]]; then
                break
            else
                _params+=( "$_param" )
            fi
        fi
        if [ "$_param" = "$_option" ]; then
            _found=1
        fi
    done
    if [ $_found = 1 ]; then
        $_callback "${_params[@]}"
        return 0
    else
        return 1
    fi
}

#  List the names of main script
#+ functions. Names contained
#+ in the 'keywords' are discarded.
_list_commands() {
    declare -a _functions=(
        $( declare -F )
    )
    local _length=${#_functions[@]}
    if (( _length > 0 )); then
        for _function in "${_functions[@]}"; do
            local _name=""
            local _belong=""
            local _is_key=0
            _name=$( echo "$_function" | cut -d ' ' -f 3 )
            _belong=$( grep "${_name}\s*()" "$0" )
            _is_key=$( _is_keyword "$_name" )
            if [ -n "$_belong" ] \
                   && [[ "$_name" != "_"* ]] \
                   && (( _is_key == 0 )); then
                echo "$_name"
            fi
        done
    fi
}
expr "$*" : ".*--list" > /dev/null \
    && _list_commands \
    && exit 0

#  Add a new variable, into script,
#+ which will be taken as priority
#+ config for 'get' function.
#
#  -param $1 Name of the entry
#  -param $2 Value of the entry
_set_config() {
    local _name=${1:-''}
    local _val=${2:-''}
    eval "$_name=$_val"
    info "Set temporal [$_name] with value [$_val]"
}
expr "$*" : ".*--set" > /dev/null \
    && _look_for_params "_set_config" "--set" "$@"

#  Save key-value to 'ws/config.json'
#+ using 'put' function.
#
#  -param $1 Name of the entry
#  -param $2 Value of the entry
_add_config() {
    local _name=${1:-''}
    local _val=${2:-''}
    put "$_name" "$_val"
}
expr "$*" : ".*--add" > /dev/null \
    && _look_for_params "_add_config" "--add" "$@" \
    && exit 0

#  Get key-value from 'ws/config.json'
#+ using 'get' function.
#
#  -param $1 Name of the entry
_get_config() {
    local _name=${1:-''}
    local _val=""
    if [ -n "$_name" ]; then
        _val=$( get "$_name" )
    fi
    echo "$_val"
}
expr "$*" : ".*--get" > /dev/null \
    && _look_for_params "_get_config" "--get" "$@" \
    && exit 0

#  Remove key-value to 'ws/config.json'
#+ using 'remove' function.
#
#  -param $1 Name of the entry
_remove_config() {
    local _name=${1:-''}
    remove "$_name"
}
expr "$*" : ".*--remove" > /dev/null \
    && _look_for_params "_remove_config" "--remove" "$@" \
    && exit 0

#  List the keys of 'ws/config.json'.
_get_config_keys() {
    local _keys=(
        $( jq "keys | .[]" "ws/config.json" )
    )
    local _length=${#_keys[@]}

    if (( _length > 0 )); then
        for _key in "${_keys[@]}"; do
            echo "$_key" | sed -e 's/^"//' -e 's/"$//'
        done
    fi
}
expr "$*" : ".*--get-keys" > /dev/null \
    && _get_config_keys \
    && exit 0

#  Set host value to 'ws/config.json'.
#  Execution takes the following steps:
#    1. Get host from the parameter.
#    2. Get current host from
#+      'ws/config.json', if parameter
#+      is empty.
#    3. Look for a host from listed
#+      array 'hosts' defined in
#+      'ws/config.json'. Array
#+      must have the form:
#+      '[{key:"" , value:""}]''
#    4. If exist host in listed
#+      hosts, that will be the
#+      current host.
#
#  -param $1 Name of the host or
#+           host value
_set_host() {
    local _host=${1:-''}
    if [ -z "$_host" ]; then
        _host=$( get host )
    fi
    local _val=""
    _val=$( get "hosts | .[] | select(.key==\"$_host\") | .value" )
    if [ -n "$_val" ] && [ "$_val" != "null" ]; then
        _host="$_val"
    fi
    DOMAIN="$_host"
    put host "\"$_host\""
    info "Set DOMAIN with [$_host]"
}
expr "$*" : ".*--host" > /dev/null \
    && _look_for_params "_set_host" "--host" "$@"

#  Set domain to 'localhost'. Default
#+ port is 8080 but it can be specified
#+ as first parameter and will override
#+ default port.
#  Protocol is changed as well and takes
#+ 'http' as value.
#
#  -param $1 Port value
_set_localhost() {
    local _port=${1:-''}
    if [ -z "$_port" ]; then
        _port="8080"
    fi
    PROTOCOL="http"
    DOMAIN="localhost:$_port"
    info "Set PROTOCOL with [$PROTOCOL]"
    info "Set DOMAIN with [$DOMAIN]"
}
expr "$*" : ".*--local" > /dev/null \
    && _look_for_params "_set_localhost" "--local" "$@"

#  Set 'AUTH_MODE' to 'HEADER'.
_auth_header() {
    AUTH_MODE="HEADER"
}
expr "$*" : ".*--auth-header" > /dev/null \
    && _auth_header "$@"

#  Set 'AUTH_MODE' to 'QPARAM'.
_auth_qparam() {
    AUTH_MODE="QPARAM"
}
expr "$*" : ".*--auth-qparam" > /dev/null \
    && _auth_qparam "$@"

#  Get saved editor command from
#+ 'ws/config.json and the value
#+ is assigned to 'EDITOR_COMMAND'.
_open_editor() {
    EDITOR_COMMAND="$( get editorCommand )"
}
expr "$*" : ".*--open" > /dev/null \
    && _open_editor "$@"

#  Clean all files from 'output'
#+ directory.
_clean_output_files() {
    if [ -d output ]; then
        declare -a _selected=(
            $( find "output" -name "*" -type f )
        )
         local _length=${#_selected[@]}
        if (( _length > 0 )); then
            for _file in "${_selected[@]}"; do
                info "Removed [$_file] output"
            done
            rm -rf output/*
        fi
    fi
}
expr "$*" : ".*--clean" > /dev/null \
    && _clean_output_files \
    && info "Cleaning completed" \
    && exit 0


# ---------- Add-ons

#  Add-on files.
#  Filename must have
#+ the form: '<name>_ext'
declare -a _add_ons_ext=(
    $( find . -name "*_ext" -type f )
)

#  Add-on files length.
readonly _add_ons_ext_length=${#_add_ons_ext[@]}

#  If exists add-on files
#+ they will be sourced.
if (( _add_ons_ext_length > 0 )); then
    for _add_on in "${_add_ons_ext[@]}"; do
        eval ". $_add_on"
        info "Add-on [$_add_on] sourced"
    done
else
    info "No add-ons sourced"
fi


# ---------- Main

#  Skip main code flag
readonly _skip_http_api=${SKIP_HTTP_API:-''}

#  Main code:
#    1. Get the 'command' input.
#    2. Set the exist 'main' function flag.
#    3. Discard 'command' if has 'option'
#+      format.
#    4. If 'command' is present, execute
#+      the following request lifecycle:
#       a. Execute before-request tasks.
#       b. Execute the command.
#       c. Set request method based on
#+         command name if it was not
#+         assigned during the command
#+         execution.
#       d. Execute the request.
#       e. Execute after-request tasks.
#       f. Execute open editor task.
#    5. If 'main' is present, execute
#+      the following request lifecycle:
#       a. Execute before-request tasks.
#       b. Execute 'main' function.
#       c. Execute the request.
#       d. Execute after-request tasks.
#       e. Execute open editor task.
#    6. Finally function is executed.
if [ "$_skip_http_api" != "true" ]; then
    trap _finally_http_api EXIT

    _command=${1:-''}

    #  shellcheck disable=SC2034
    _has_main=$( declare -f 'main' > /dev/null ; echo $? )

    if [[ "$_command" == "--"* ]]; then
        _command=""
    fi

    info "Init request"

    if [ -n "$_command" ]; then
        info "Executing [$_command] command"
        _before_request
        eval "$_command"
        _set_method "$_command"
        _request
        _after_request
        _editor_command
    elif (( _has_main == 0 )); then
        info "Executing [main] command"
        _before_request
        main
        _request
        _after_request
        _editor_command
    else
        info "No command to execute"
    fi

    info "Request completed"
fi
